% \setchapterimage[6cm]{seaside}
\setchapterpreamble[u]{\margintoc}
\chapter{The Observational Calculus of Constructions}
\labch{layout}
\label{ch:observational}

% \sideremark{The \SetoidCC acronym stands for the ``Observational Calculus of 
% Constructions''.}
In this chapter we present the observational calculus of constructions 
(\SetoidCC), which is a flavor of Altenkirch, McBride and Swierstra's 
observational type theory \cite{altenkirchAl:plpv2007}.
% 
\SetoidCC extends Martin-Löf Type Theory with support for impredicative 
propositions and an observational equality that satisfies UIP, function 
extensionality and proposition extensionality, while preserving
the computational properties of \MLTT. 

We start in \cref{sec:generalities} with some informal considerations about the system, 
then we delve into a detailed description of the typing rules in 
\cref{sec:typing-rules}, and finally we conclude 
with an overview of the meta-theoretical properties of
\SetoidCC in \cref{sec:properties}.

\section{Overview of the Observational Calculus of Constructions}
\label{sec:generalities}

\subsection{Constructions and Propositions}

\SetoidCC separates types into two layers: a proof-relevant layer for 
\emph{constructions} and a proof-irrelevant layer for \emph{propositions}. 

The proof-relevant types inhabit the universe hierarchy \( \Type_i \).
% 
This layer works exactly like usual Martin-Löf Type Theory, and
contains familiar types
\sideremark{In fact, \MLTT can be embedded in the proof-relevant layer of
\SetoidCC as we will see.}
such as the type of natural numbers, \( \Pi \)-types, \( \Sigma \)-types or 
universes; but also new types such as subset types and quotient types that
we will introduce in due course.
% 
Generally speaking, proof-relevant objects correspond to mathematical 
constructions or programs, depending on which side of the Curry-Howard 
correspondance you are most familiar with.

The second layer corresponds to the impredicative universe of propositions 
\( \sProp \), and it behaves rather differently.
% 
Indeed, propositions are \emph{definitionally proof-irrelevant types}, which 
means that any two inhabitants of a type \( \tm{A}{\sProp} \) are convertible
simply by virtue of having type \( A \):
% 
\sideremark{We use the triple equal symbol \( \equiv \) to denote convertibility, 
also referred to as definitional equality.}
% 
\[
\inferrule{\tytm{\Gamma}{A}{\sProp} \\ \tytm{\Gamma}{t, u}{A}}{\eqtm{\Gamma}{t}{u}{A}}
\]

This corresponds to the universe of strict propositions
\( \varsProp \) described in~\sidecitet{gilbert:hal-01859964} and implemented 
in \Coq and \Lean.
% 
Propositions contain no computational information whatsoever, but they may be 
used to express logical constraints on proof-relevant objects.
% 
Examples of propositions will include True, False, logical connectors and the 
observational equality.

These two layers are far from being hermetically sealed, though:
% 
the entire point of \SetoidCC is to leverage the flexibility of 
proof-irrelevance to extend the proof-relevant fragment with extensionality 
principles.
% 
For instance, the elimination principle for the observational equality
allows us to prove function extensionality even for the
\emph{inductive} equality of \SetoidCC, which lives in the proof-relevant layer!

% \defnote{function extensionality}{Recall that function extensionality means that
% pointwise equal functions are in fact equal: \( (\forall x, f\ x = g\ x) \to f = g \).} 
% for the \emph{inductive equality}

\subsection{The Observational Equality}
\label{sec:obseq-intro}

A central feature of \SetoidCC is that every proof-relevant
% 
\sideremark{Proof-irrelevant propositions, for their part, do not need to be equipped 
with an equality relation: since any two inhabitants are convertible, they
would always be equal by reflexivity.}
% 
type \( A \) comes equipped with a proof-irrelevant \emph{observational equality} 
type, that we write \( {\Obseq[A]{t}{u}} \).

As suggested by its name, this equality is built around the idea that two 
objects should be identified when they behave similarly with respect to all 
obervations we can make on them.
% 
For instance, the observations we can make on a function \( f : \Nat \to \Nat \) 
basically amount to applying \( f \) to some number \( n \), and computing the
result. 
% 
Thus, two integer functions \( f \) and \( g \) are observationally equal 
when \( \Obseq[\Nat]{f\ n}{g\ n} \) for all \( n : \Nat \),
which is the principle of function extensionality.

In this regard, the observational equality is similar to the univalent equality 
found in Homotopy Type Theory \sidecite{hottbook}. 
% 
But it is also fundamentally different: 
% 
by virtue of being a proof-irrelevant proposition, the observational equality 
validates the principle of Uniqueness of Identity Proofs (\UIP), while the 
equality of \HoTT equips types with the complex structure of a higher groupoid.
% 
In other words, \SetoidCC is a language for set-like objects and set-based 
mathematics, not higher mathematics.
% 
In exchange for the comfortable simplicity of \UIP, the observational equality
is not univalent, and in particular it does not identify isomorphic types.

From a computational perspective, the observational equality behaves very 
differently from the usual Martin-Löf Identity Type.
% 
The equality type \( \Obseq[A]{t}{u} \) should be understood 
as an \emph{eliminator} that computes by reducing the type \( A \) to its 
normal form, and then pattern-matches on it to produce the equality 
relation which is appropriate for \( A \). For instance, if \( A \) happens
to be a function type, then the observational equality will reduce to the
statement of function extensionality:
\[
	\Obseq[\Fun{A}{B}]{f}{g} \quad \Longrightarrow \quad \Depfun{A}{\Obseq[B]{f\ x}{g\ x}}.
\]
Likewise, all the other type formers have corresponding computation rules that
prescribe the behavior of the observational equality on their inhabitants.

\subsection{Eliminating Equality with Type Casting}
\label{sec:cast-intro}

For the observational equality to be of any interest, we need a way to
use it in constructions and proofs: 
% 
\sideremark{This principle is called the Leibniz rule. It should apply
to both relevant and irrelevant predicates.}
% 
from an inhabitant of \( P\ a \) and a proof of \( \Obseq{a}{b} \), we should 
be able to derive an inhabitant of \( P\ b \).
% 
\[
\inferrule{\tytm{\Gamma}{A}{\Type} \\ \tytm{\Gamma}{a, b}{A} \\ \tytm{\Gamma}{e}{\Obseq[A]{a}{b}} \\ \tytm{\Gamma}{P}{A \to \Type} \\ \tytm{\Gamma}{t}{P\ a}}{\tytm{\Gamma}{?}{P\ b}}
\]
% 
To this end, \SetoidCC provides the two primitive eliminators \( \transportName \)
% 
\sideremark{We use the light blue font to help distinguish \SetoidCC keywords 
from the body text. We do not use it for mathematical symbols however, since 
they are easy enough to identify as is.}
% 
and \( \castName \).

\paragraph*{Transport}
Elimination of equalities into the proof-irrelevant layer is done with 
\( \transportName \). 
% 
Since the result is computationally irrelevant, this operator is not required 
to satisfy any kind of equation---in the proof-irrelevant world, all 
equations hold true as long as they are well-typed---and
thus \( \transportName \) is merely an axiom that postulates the Leibniz
rule for propositional predicates, with no computation rules whatsoever.
% 
\[
\inferrule{\tytm{\Gamma}{A}{\Type} \\ \tytm{\Gamma}{a, b}{A} \\ \tytm{\Gamma}{e}{\Obseq[A]{a}{b}} \\ \tytm{\Gamma}{P}{A \to \sProp} \\ \tytm{\Gamma}{t}{P\ a}}{\tytm{\Gamma}{\transport{A}{a}{P}{t}{b}{e}}{P\ b}}
\]

We can use it to derive important properties of the observational equality, 
such as the fact that it is an equivalence relation, or that it is preserved
by functions:
\sideremark{The variables \( A, B, x, y \) are implicitly quantified over the 
appropriate types, which we omit to avoid clutter.}
\[
\metaop{ap} : \Depfun[f]{A \to B}{\Fun{\Obseq[A]{x}{y}}{\Obseq[B]{f\ x}{f\ y}}}.
\]

\paragraph*{Type casting}
On the other hand, the \( \castName \) operator eliminates equalities into the 
proof-relevant layer by allowing to cast terms between two observationally
equal types.
% 
\[
\inferrule{\tytm{\Gamma}{A, B}{\Type} \\ \tytm{\Gamma}{e}{\Obseq[\Type]{A}{B}} \\ \tytm{\Gamma}{t}{A}}{\tytm{\Gamma}{\cast{A}{B}{e}{t}}{B}}
\]
% 
Given a proof \( e : \Obseq[\Type]{A}{B} \) and an inhabitant \( t : A \), the
term \( \cast{A}{B}{e}{t} \) produces an inhabitant of \( B \) by computing the 
normal forms of the types \( A \) and \( B \), and then picking an appropriate 
computation rule according to their head constructors.
% 
For instance, if \( A \) and \( B \) are two function types, then the cast
will reduce to a function that casts back and forth:
\sideremark{In this computation, \( e \) is a proof of 
\( {\Obseq{\Fun{A}{B}}{\Fun{A'}{B'}}} \), which is actually convertible to
\( {(\Obseq{A}{A'})} \land {(\Obseq{B}{B'})}. \) We write \( e_1 \) and 
\( e_2 \) for its projections.}
\begin{align*}
& \cast{\Fun{A}{B}}{\Fun{A'}{B'}}{e}{f} \\
& \qquad \Longrightarrow \quad
\lam{A'}{\cast{B}{B'}{e_2}{f\ \cast{A'}{A}{{e_1}^{-1}}{x}}}.
\end{align*}
% 
Just like with the observational equality, every type constructor comes with
rules that describe the behavior of \( \castName \) on its elements.
% 
Note that the equality proof \( e \) plays no computational role, and is just
here to ensure that the cast is consistent. Thus \( \castName \) is really
an eliminator of the universe of proof-relevant types \( \Type \) rather than
an eliminator of the observational equality.

The \( \castName \) operator, despite its apparent simplicity, is in fact enough
to derive the \( J \) eliminator of \MLTT. Indeed, it is well-known that the 
\( J \) eliminator is equivalent to the Leibniz rule and the contractibility 
of singletons, but the contractibility of singletons is implied by 
proof irrelevance of the equality, and the Leibniz rule is a consequence 
of \( \metaop{ap} \) and \( \castName \). The corresponding term is spelled
out in \cref{sec:inductive-equality}.

\section{The Formal System \SetoidCC}
\label{sec:typing-rules}

\subsection{Syntax}

The syntax of the sorts, contexts, terms and types of the system is
specified in \cref{fig:syntax}.
% 
In order to distinguish them from the body text more easily, we will write 
keywords of \SetoidCC in \( \metaop{blue} \).

The formal system features dependent products 
$\Depfunannotated{A}{B}{}{\Univ}{\Univ'}$, and dependent sums 
$\Depsumannotated{A}{B}{}{\Univ}{\Univ'}$.
% 
In an attempt to maximize readability, we will omit the sort annotations on 
\( \Pi \) and \( \Sigma \) when they can be inferred from the context, and we 
write them as respectively \( \Fun{A}{B} \) and \( A \times B \) when \( B \) 
does not depend on \( A \). 
% 
On top of this, the system supports some inductive types, which include the 
standard examples of natural numbers \( \Nat \) and inductive equality 
\( \metaop{Id} \) but also the less standard quotient types and box types.

We will introduce some syntactic sugar for constructions of \SetoidCC,
such as \( \top \) for the true proposition or \( \metaop{ap} \) for the proof
that functions preserve the observational equality (cf \cref{sec:cast-intro}).
% 
Such notations will be introduced throughout the chapter, but for convenience they are 
collected in appendix \ref{sec:ap:sugar}.
% 
The capture-avoiding substitution of a variable \( x \) in a term \( A \) by the 
term \( t \) is noted \( \subst{B}{t} \).

% SetoidCC syntax
\begin{figure*}[!h]
	\begin{small}
		\[
		\begin{array}{lclcl}
		i,j				& \bnfin	& \Nat
		& & \text{Universe levels} \\
		\Univ			& \bnfis	& \Type_i \qsep \sProp
		& & \text{Universes} \\
		\Gamma , \Delta & \bnfis	& \emptyctx \qsep \extctxannotated{\Gamma}{A}{\Univ}
		& & \text{Contexts} \\
		t,u,v,m,n,e,A,B   & \bnfis	& x \qsep \Univ 
		& & \text{Variables and Universes} \\
						& \sep		& \emptyrec{A}{t} \qsep \Empty
		&  & \text{Empty type} \\
						& \sep		& \Obseq[A]{t}{u} \qsep \refl{t}{A} 
									\qsep \transport{A}{t}{B}{u}{t'}{e}	
		&  & \text{Observational equality} \\
						& \sep		& \cast{A}{B}{e}{t} \qsep \castrefl{A}{t}
		&  & \text{Type cast} \\
						& \sep		& \Nat 
									\qsep \zero \qsep \suc{t} \qsep \natrec{A}{t}{u}{n}
		&  & \text{Natural numbers} \\
						& \sep		& \Depfunannotated{A}{B}{s}{\Univ}{\Univ'} 
									\qsep \lam{A}{t} \qsep t\ u 
		& & \text{Dependent products} \\
						& \sep		& \Depsumannotated{A}{B}{s}{\Univ}{\Univ'}
									\qsep \relpair{t}{u} \qsep \relfst{t} \qsep \relsnd{t} 
		&  & \text{Dependent sums} \\
						& \sep		& \Quo{A}{B} 
									\qsep \quo{t} \qsep \quorec{A}{t}{u}{v} 
		&  & \text{Quotient Types} \\
						& \sep		& \Boxt{A} 
									\qsep \boxt{t} \qsep \unboxt{t}
		&  & \text{Box Types} \\
						& \sep		& \Id{A}{t}{u} 
									\qsep \id{t} \qsep \idpath{t} \qsep \J{A}{t}{B}{u}{v}{e}
		&  & \text{Inductive equality}
		\end{array}
		\]
	\end{small}
	\caption{Syntax of \SetoidCC}
	\label{fig:syntax}
\end{figure*}

\subsection{Structure of the Rules}

The typing rules of \SetoidCC are based on four different judgments: 
\begin{center}
  \begin{tabular}{lr}
	\( \wfctx{\Gamma} \) & {the context \( \Gamma \) is well-formed} \\
	\( \tytmannotated{\Gamma}{t}{A}{\Univ} \) & {the term \( t \) has type \( A \) in context \( \Gamma \)} \\
	\( \eqtmannotated{\Gamma}{t}{u}{A}{\Univ} \) & {\( t \) and \( u \) are convertible at type \( A \) in context \( \Gamma \)} \\
	\( \redannotated{\Gamma}{t}{u}{A}{\Type_i} \) & \quad {the term \( t \) reduces to \( u \) at type \( A \) in context \( \Gamma \)}
  \end{tabular}
  \sideremark[*-4]{In all the judgments, \( \Univ \) is either \( \Type_i \) or \( \sProp \).
  Note that the reduction only makes sense for proof-relevant terms, so it will never
  apply to a term in \( \sProp \).}
\end{center}
The typing and convertibility rules define the algebraic theory of 
\SetoidCC, while the reduction rules describe a weak-head normalization 
algorithm that we will use to compute normal forms for the well-typed 
terms (see \cref{sec:weak-head}).
% 
In case the type is a sort \( \Univ \), we shorten 
\( {\tytmannotated{\Gamma}{A}{\Univ}{\Univ^+}} \)
% 
\sideremark{We use \( \Univ^+ \) to represent the next bigger sort to \( \Univ \). It is defined by 
	\begin{align*} \sProp^+ & := \Type_0 \\ \Type_i^+ & := \Type_{i+1}
	\end{align*}}
% 
to \( {\tytm{\Gamma}{A}{\Univ}} \), and we similarly shorten conversion and reduction.

As is often the case in type theory, the rules are organized in a very 
systematic structure:
% 
every type former comes with rules that describe its formation, introduction, 
elimination and computation.
% 
In \SetoidCC, every type former must also add rules that describe the 
observational equality on top of this.

\subsection{Generic Rules}

\paragraph*{Contexts}
Rules~\nameref{inferrule:ctx-nil}, \nameref{inferrule:ctx-cons} and \nameref{inferrule:var} describe the
usual formation of contexts and typing of variables. 
% 
\begin{mathpar}
	\inferrule[Ctx-Nil]
		{ }
		{\wfctx{\emptyctx}}
	\ilabel{inferrule:ctx-nil}
	\and
	\inferrule[Ctx-Cons]
		{\wfctx{\Gamma} \\ \tytm{\Gamma}{A}{\Univ}}
		{\wfctx{\extctxannotated{\Gamma}{A}{\Univ}}}
	\ilabel{inferrule:ctx-cons}
	\and
	\inferrule[Var]
		{\wfctx{\Gamma} \\ \inctx{\Gamma}{A}{\Univ}}
		{\tytmannotated{\Gamma}{x}{A}{\Univ}}
	\ilabel{inferrule:var}
\end{mathpar}

\paragraph*{Conversion}

Conversion is an equivalence relation that is preserved by typing, and it 
subsumes the reduction of proof-relevant terms and the convertibility of
proof-irrelevant terms.
% 
\begin{mathpar}
	\inferrule[conv]
		{\tytmannotated{\Gamma}{t}{A}{\Univ}
			\\ \eqtm{\Gamma}{A}{B}{\Univ}}
		{\tytmannotated{\Gamma}{t}{B}{\Univ}}
	\ilabel{inferrule:conv}
	\and
	\inferrule[Refl]
		{\tytmannotated{\Gamma}{t}{A}{\Univ}}
		{\eqtmannotated{\Gamma}{t}{t}{A}{\Univ}}
	\ilabel{inferrule:reflexivity}
\end{mathpar}
\begin{mathpar}
	\inferrule[Sym]
		{\eqtmannotated{\Gamma}{t}{u}{A}{\Univ}}
		{\eqtmannotated{\Gamma}{u}{t}{A}{\Univ}} 
	\ilabel{inferrule:sym}
	\and
	\inferrule[Trans]
		{\eqtmannotated{\Gamma}{t}{t'}{A}{\Univ}
			\and \eqtmannotated{\Gamma}{t'}{u}{A}{\Univ}}
		{\eqtmannotated{\Gamma}{t}{u}{A}{\Univ}}
	\ilabel{inferrule:trans}
\end{mathpar}
\begin{mathpar}
	\inferrule[Red-Conv]
		{\redannotated{\Gamma}{t}{u}{A}{\Type_i}}
		{\eqtmannotated{\Gamma}{t}{u}{A}{\Type_i}}
	\ilabel{inferrule:red-conv}
	\and
	\inferrule[Proof-Irrelevance]
		{\tytmannotated{\Gamma}{t,u}{A}{\sProp}}
		{\eqtmannotated{\Gamma}{t}{u}{A}{\sProp}}
	\ilabel{inferrule:proof-irrelevance}
\end{mathpar}

On top of this, we need to add bureaucratic congruence rules which make sure
that each constructor preserves the judgmental equality 
(say for instance, if \( t \equiv u \) then \( \suc{t} \equiv \suc{u} \)).
% 
Since these rules present little interest, we do not reproduce them here and
refer the interested reader to appendix \ref{sec:ap:cong}.

\subsection{The Logical Layer}

\paragraph*{Impredicative \( \Pi \)-Types}

Given a type \( A \) and a proof-irrelevant family \( B : A \to \sProp \)
on it, the system allows the formation of a proof-irrelevant \( \Pi \)-Type, 
with the usual introduction and elimination rules.
\sideremark{There is no need for \( \beta \)-reduction or an \( \eta \) rule. 
Since this type lives in the proof-irrelevant world, both conversion rules
are a consequence of proof irrelevance.}
% 
\begin{mathpar}
	\inferrule[$\Pi$-Irr-Form]
		{%\tytm{\Gamma}{A}{\Univ}
			\tytm{\extctxannotated{\Gamma}{A}{\Univ}}{B}{\sProp}}
		{\tytm{\Gamma}{\Depfunannotated{A}{B}{\Univ}{\Univ}{\sProp}}{\sProp}}
		{}
	\ilabel{inferrule:pi-irr-form}
	\and
	\inferrule[Fun-Irr]
		{\tytmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t}{B}{\sProp}}
		{\tytmannotated{\Gamma}{\lam{A}{t}}{\Depfun{A}{B}}{\sProp}}
	\ilabel{inferrule:pi-irr-intro}
	\and
	\inferrule[App-Irr]
		{\tytmannotated{\Gamma}{t}{\Depfun{A}{B}}{\sProp}
			\\ \tytmannotated{\Gamma}{u}{A}{\Univ}}
		{\tytmannotated{\Gamma}{t\ u}{\subst{B}{u}}{\sProp}}
	\ilabel{inferrule:pi-irr-elim}
\end{mathpar}
% 
If the domain \( A \) is proof-relevant, then the \( \Pi \)-type plays 
the role of a universal quantification. If \( A \) is a proposition 
instead, then the \( \Pi \)-type plays the role of a dependent implication 
between two propositions.

Note that this rule makes \( \sProp \) into an 
\defnote{impredicative}{A sort is said to be impredicative if it is closed under 
dependent products over any index type.}
sort.
% 
In particular, it allows the definition of self-referential propositions,
which quantify over the type \( \sProp \) of all propositions and may thus
be applied to themselves.
%
In addition to providing a tremendous amount of raw logical power, 
impredicativity is a remarkably flexible tool to define new propositions and
abstractions.
% 
This versatility makes impredicativity a crucial ingredient of numerous 
tools in constructive mathematics, such as Tarski's fixed point theorem or 
lattice theory~\sidecite{paco}.

\paragraph*{Dependent Conjunctions and Existential Types}
% 
As a testament to the expressive power of impredicativity, we use it to 
derive new logical primitives, using the well-known technique of impredicative 
encodings.

Given a proposition \( A \) and a second proposition \( B \) that depends on 
\( A \), we form the dependent conjunction of \( A \) and \( B \) as follows
\[
	\Exists{A}{B} \quad := \quad \Depfun[X]{\sProp}{\Fun{(\Fun{\Depfun{A}{B}}{X})}{X}}.
\]
In presence of proof-irrelevance, this encoding provides everything we might
ask of a dependent conjunction: on the one hand, from a proof \( a \) of 
\( A \) and a proof \( b \) of \( \subst{B}{a} \), we can derive a proof of 
\( \Exists{A}{B} \) as a simple lambda abstraction
\[
	\pair{a}{b} \quad := \quad \lambda\ X\ H\ .\ H\ a\ b
\]
and conversely, given a proof \( t \) of \( \Exists{A}{B} \) we define the 
following eliminators:
\[
\begin{array}{rll}
	\fst{t} \quad & := \quad t\ A\ (\lambda\ a\ b\ .\ a) & : \quad A \\
	\snd{t} \quad & := \quad t\ (B\ \fst{t})\ (\lambda\ a\ b\ .\ b) & : \quad B\ \fst{t}.
\end{array}
\]

When \( A \) is a proof-relevant type and \( B \) is a proof-irrelevant proposition
that depends on \( A \), we use the same construction to define the 
existential quantifier \( \varExists{A}{B} \). 
\[
	\varExists{A}{B} \quad := \quad \Depfun[X]{\sProp}{\Fun{(\Fun{\Depfun{A}{B}}{X})}{X}}.
\]
In the case of an existential quantifier, the projections \( \metaop{fst} \) and 
\( \metaop{snd} \) are ill-typed, because we cannot use \( A \) as an argument
of type \( \sProp \). 
% 
This is only fair, since being able to recover an inhabitant of \( A \) from an
a proof of propositional existence would require to extract computational 
content from a proof-irrelevant object.

\paragraph*{Truth and Falsity}

To represent absurdity, \SetoidCC features the false 
proposition $\Empty$, from which we can define the true proposition 
$\Unit$.

Besides its formation rule (Rule~\nameref{inferrule:empty-form}), the false proposition
comes with an elimination \sideremark{This large elimination rule means that we could not replace 
\( \Empty \) with some impredicative encoding.}
principle (Rule~\nameref{inferrule:empty-elim}) that 
applies to both proof-irrelevant and proof-relevant types.

% 
\begin{mathpar}
	\inferrule[$\Empty$-Form]
		{\wfctx{\Gamma}}
		{\tytm{\Gamma}{\Empty}{\sProp}}
	\ilabel{inferrule:empty-form}
	\and
	\inferrule[$\Empty$-Elim]
		{\tytm{\Gamma}{A}{\Univ}
			\\ \tytmannotated{\Gamma}{t}{\Empty}{\sProp}}
		{\tytmannotated{\Gamma}{\emptyrec{A}{t}}{A}{\Univ}}
	\ilabel{inferrule:empty-elim}
\end{mathpar}
% 
In the theory implemented by \Coq, this rule constitutes the 
unique connection between the proof-irrelevant and relevant types. 
% 
This means that the only way to use information from a proof-irrelevant term 
to build a proof-relevant term is by using a proof of $\Empty$, which
amounts to proving that actually we are in an inaccessible branch or
impossible case.
%
In \SetoidCC however, there is another way of using proof irrelevant 
information to build a proof relevant term, by transporting (or casting) 
along a proof of equality.

The true proposition on the other hand only requires a formation rule and a 
constructor. It does not require an eliminator, since the usual one 
can be derived from proof irrelevance.
% 
Thus, we can simply define them as 
\[ 
	\begin{array}{rll}
	\Unit \quad & := \quad \Fun{\Empty}{\Empty} & : \quad \sProp \\
	\unit \quad & := \quad \lam{\Empty}{x} & : \quad \Unit.
	\end{array}
\]

\paragraph*{The Observational Equality}

As we explained in \cref{sec:obseq-intro}, a central feature of \SetoidCC is 
that every proof-relevant type comes equipped with a proof-irrelevant equality 
type, noted $\Obseq[A]{t}{u}$ and a canonical way to inhabit it, with the 
reflexivity constructor $\refl{t}{A}$.
%
\begin{mathpar}
	\inferrule[Eq-Form]
		{%\tytm{\Gamma}{A}{\Type_i} \\
			\tytmannotated{\Gamma}{t}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{A}{\Type_i}}
		{\tytm{\Gamma}{\Obseq[A]{t}{u}}{\sProp}}
	\ilabel{inferrule:eq-form}
	\and
	\inferrule[Refl]
		{% \tytm{\Gamma}{A}{\Type_i} \\
			\tytmannotated{\Gamma}{t}{A}{\Type_i}}
		{\tytmannotated{\Gamma}{\refl{t}{A}}{\Obseq[A]{t}{t}}{\sProp}}
	\ilabel{inferrule:refl}
\end{mathpar}
%
The equality type of \SetoidCC should not be seen as a type former like
the identity type of \MLTT, but rather as an eliminator that produces a
proposition by case analysis on the head constructor of the type \( A \).

To transport a proof of a proposition along an observational equality, 
\SetoidCC provides the eliminator \( \transportName \).
%
\begin{mathpar}
	\inferrule[Transport-$\sProp{}$]
		{%\tytm{\Gamma}{A}{\Type_i}
			\tytmannotated{\Gamma}{t,t'}{A}{\Type_i}
			\quad \tytm{\extctx[x]{\Gamma}{A}}{B}{\sProp} \\
			% \quad \tytm{\Gamma}{B}{\sProp[j]}
			\tytmannotated{\Gamma}{u}{\subst[x]{B}{t}}{\sProp}
			%\quad \tytmannotated{\Gamma}{t'}{A}{\Univ}
			\quad \tytmannotated{\Gamma}{e}{\Obseq[A]{t}{t'}}{\sProp}}
		{\tytmannotated{\Gamma}{\transport{A}{t}{B}{u}{t'}{e}}{\subst[x]{B}{t'}}{\sProp}}
	\ilabel{inferrule:transport-prop}
\end{mathpar}
%
Since it only ever constructs computationally irrelevant terms, this eliminator
does not need any computational rule.
%
Using $\transportName$, we can prove that the observational equality is in
fact an equivalence relation, and we note $\sym{e}$ for the inverse of $e$, 
\( \transitivity{e}{e'} \) for the transitivity, and $\ap{f}{e}$ for the 
preservation of equality by non-dependent function.

To deal with elimination of equality in a proof relevant context, 
\SetoidCC provides a \( \castName \) primitive that handles transport between 
two propositionally equal proof relevant types.
% 
\begin{mathpar}
	\inferrule[Cast]
		{% \tytm{\Gamma}{A}{\Univ_i}   \quad \tytm{\Gamma}{B}{\Univ_i}
			\tytmannotated{\Gamma}{e}{\Obseq[{\Univ}]{A}{B}}{\sProp}
			\quad \tytmannotated{\Gamma}{t}{A}{\Univ}}
		{\tytmannotated{\Gamma}{\cast{A}{B}{e}{t}}{B}{\Univ}}
	\ilabel{inferrule:cast}
\end{mathpar}
% 
Note that our cast operation also applies to proof-irrelevant
types.
% 
This is technically unnecessary as \( \transportName \) subsumes this case, 
but it will allow us to write more uniform reduction rules.
%
The term \( \cast{A}{B}{e}{t} \) computes by case analysis on \( A \) and 
\( B \), with specific computation rules for each type former 
(which are described in \cref{sec:universe}).
% 
The equality proof \( e \) plays no role in the computation whatsoever, and 
is only here to make sure the cast is consistent.

By default, \( \castName \) applied to reflexivity only reduces to the
identity function if the terms \( A \) and \( B \) are closed. 
% 
To make up for this state of affairs, \SetoidCC provides a proof-irrelevant 
axiom $\castreflName$ which asserts that casting along reflexivity is the 
identity.
% 
\begin{mathpar}
	\inferrule[Cast-Refl]
		{%\tytm{\Gamma}{A}{\Univ_i}
			\tytmannotated{\Gamma}{t}{A}{\Type_i} \\
			\tytmannotated{\Gamma}{e}{\Obseq[{\Type_i}]{A}{A}}{\sProp}}
		{\tytmannotated{\Gamma}{\castrefl{A}{t}}{\Obseq[A]{t}{\cast{A}{A}{e}{t}}}{\sProp}}
	\ilabel{inferrule:cast-refl}
\end{mathpar}
% 
In \cref{ch:extensions}, we study a slight variant of \SetoidCC dubbed \SetoidCCplus
where the rule \nameref{inferrule:cast-refl} holds up to definitional equality.
% but its normalization and canonicity are only conjectural.

\subsection{Dependent products}

From a type \( A \) and a proof-relevant dependent family \( B : A \to \Type_i \),
we can form a proof-relevant dependent product, no matter what is the sort of the
domain \( A \).
% 
The resulting type has a universe level equal to the maximum of the level of
the domain and the level of the codomain (where \( \sProp \) is considered to have
level 0).
% 
\sideremark{The notation \( \Type_{\mathrm{max}(i,\Univ)} \) treats \( \sProp \) 
as having universe level 0. Basically, it is equal to \( \Type_{\mathrm{max}(i,j)} \)
if \( \Univ \) is \( \Type_j \), and to \( \Type_i \) if \( \Univ \) is \( \sProp \).}
\begin{mathpar}
	\inferrule[$\Pi$-Rel-Form]
		{%\tytm{\Gamma}{A}{\Univ}
			\tytm{\extctxannotated{\Gamma}{A}{\Univ}}{B}{\Type_i}}
		{\tytm{\Gamma}{\Depfunannotated{A}{B}{\Univ}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i,\Univ)}}}
		{}
	\ilabel{inferrule:pi-form}
\end{mathpar}
%
The introduction and elimination rules for dependent products correspond to
the usual lambda-abstraction and application, with \( \beta \)-reduction and
\( \eta \)-equality.
% 
\begin{mathpar}
	\inferrule[Fun-Rel]
		{\tytmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t}{B}{\Type_i}}
		{\tytmannotated{\Gamma}{\lam{A}{t}}{\Depfunannotated{A}{B}{\Univ}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i, \Univ)}}}
	\ilabel{inferrule:pi-intro}
\end{mathpar}
% 
\begin{mathpar}
	\inferrule[App-Rel]
		{\tytmannotated{\Gamma}{t}{\Depfunannotated{A}{B}{\Univ}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i, \Univ)}}
			\\ \tytmannotated{\Gamma}{u}{A}{\Univ}}
		{\tytmannotated{\Gamma}{t\ u}{\subst{B}{u}}{\Type_i}}
	\ilabel{inferrule:pi-elim}
\end{mathpar}
% 
\begin{mathpar}
	\inferrule[$\beta$-red]
		{\tytmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t}{B}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{A}{\Univ}}
		{\redannotated{\Gamma}{(\lam{A}{t})\ u}{\subst{t}{u}}{\subst{B}{u}}{\Type_i}}
	\ilabel{inferrule:beta-red}
\end{mathpar}
% 
\sideremark{Because reduction implies conversion (rule \nameref{inferrule:red-conv}), rule \nameref{inferrule:beta-red} 
	introduces both a reduction rule and a definitional equality.}
% 
\begin{mathpar}
	\inferrule[$\eta$-Eq]
		{\tytmannotated{\Gamma}{t, u}{\Depfunannotated{A}{B}{}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i, \Univ)}}
			\\ \eqtmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t\ x}{u\ x}{B}{\Type_i}}
		{\eqtmannotated{\Gamma}{t}{u}{\Depfunannotated{A}{B}{}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i, \Univ)}}}
	\ilabel{inferrule:eta}
\end{mathpar}

Furthermore, since dependent products are proof-relevant types, we must add
rules that specify how the observational equality computes on values of type
\( \Depfun{A}{B} \).
% 
In this case, it reduces to the point-wise equality of the two functions, which
bakes the principle of function extensionality in the system.
\begin{mathpar}
	\inferrule[Eq-Fun]
		{\tytmannotated{\Gamma}{f, g}{\Depfunannotated{A}{B}{}{\Univ}{\Type_i}}{\Type_{\mathrm{max}(i, \Univ)}}}
		{\red{\Gamma}{\Obseq[\Pi A B]{f}{g}}{\Depfunannotated{A}{\Obseq[B]{f\ x}{g\ x}}{}{\Univ}{\sProp}}{\sProp}}
	\ilabel{inferrule:eq-fun}
\end{mathpar}

\subsection{Dependent Sums}
% 
\SetoidCC supports proof-relevant dependent sums, with the usual rules from
Martin-Löf Type Theory. We chose to implement \( \eta \)-extensional negative 
dependent sums, but a positive version would be just as straightforward.
\begin{mathpar}
	\inferrule[$\Sigma$-Form]
		{%\tytm{\Gamma}{A}{\Univ}
			\tytm{\extctxannotated{\Gamma}{A}{\Type_i}}{B}{\Type_j}}
		{\tytm{\Gamma}{\Depsumannotated{A}{B}{\Univ}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
		{}
	\ilabel{inferrule:sigma-form}
\end{mathpar}
% 
\begin{mathpar}
	\inferrule[Pair]
		{\tytm{\extctxannotated{\Gamma}{A}{\Type_i}}{B}{\Type_j} 
			\\ \tytmannotated{\Gamma}{t}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{\subst{B}{t}}{\Type_j}}
		{\tytmannotated{\Gamma}{\relpair{t}{u}}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
	\ilabel{inferrule:pair}
	\\\
	\inferrule[Fst]
		{\tytmannotated{\Gamma}{t}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
		{\tytmannotated{\Gamma}{\relfst{t}}{A}{\Type_i}}
	\ilabel{inferrule:fst}
	\ \inferrule[Snd]
		{\tytmannotated{\Gamma}{t}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
		{\tytmannotated{\Gamma}{\relsnd{t}}{\subst{B}{\relfst{t}}}{\Type_j}}
	\ilabel{inferrule:snd}
\end{mathpar}
% 
\begin{mathpar}
	\inferrule[Fst-Pair]
		{\tytm{\extctxannotated{\Gamma}{A}{\Type_i}}{B}{\Type_j} 
			\\ \tytmannotated{\Gamma}{t}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{\subst{B}{t}}{\Type_j}}
		{\redannotated{\Gamma}{\relfst{\relpair{t}{u}}}{t}{A}{\Type_i}}
	\ilabel{inferrule:fst-pair}
	\and 
	\inferrule[Snd-Pair]
		{\tytm{\extctxannotated{\Gamma}{A}{\Type_i}}{B}{\Type_j} 
			\\ \tytmannotated{\Gamma}{t}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{\subst{B}{t}}{\Type_j}}
		{\redannotated{\Gamma}{\relsnd{\relpair{t}{u}}}{u}{\subst{B}{t}}{\Type_j}}
	\ilabel{inferrule:snd-pair}
\end{mathpar}
\begin{mathpar}
	\inferrule[\( \eta \)-Depsum]
		{\tytmannotated{\Gamma}{t}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
		{\eqtmannotated{\Gamma}{t}{\relpair{\relfst{t}}{\relsnd{t}}}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}}
	\ilabel{inferrule:fst}
\end{mathpar}

The observational equality between two inhabitants of a dependent sum reduces
to the equality of the first and second projections---modulo a type casting, 
which is necessary for the second equality to type-check.
% 
\sideremark[*2]{Note that in this rule, \( b' \) is only an abreviation, and not
a premise — in particular, \( b' \) contains the variable \( e \), which is not in
scope yet. Although this might be a controversial choice, we will use this sort of 
abreviations fairly often for cast variables.}
% 
\begin{mathpar}
  \inferrule[Eq-Pair]{\tytmannotated{\Gamma}{t,u}{\Depsumannotated{A}{B}{}{\Type_i}{\Type_j}}{\Type_{\mathrm{max}(i,j)}}
  			\\ b' := \cast{\subst{B}{\relfst{t}}}{\subst{B}{\relfst{u}}}{\ap{B}{e}}{\relsnd{t}}} 
			{\redmultiline{\Gamma}{\Obseq[\Sigma A B]{t}{u}}{\Exists[e]{\Obseq[A]{\relfst{t}}{\relfst{u}}}
				{(\Obseq[B]{b'}{\relsnd{u}})}}{\sProp}}
		  \ilabel{inferrule:eq-pair}
\end{mathpar}


\subsection{Natural numbers}

The proof-relevant type of natural numbers $\Nat$ is the usual inductive
datatype from \MLTT. Note that its eliminator (rule~\nameref{inferrule:nat-elim}) applies
indifferently to proof-relevant types and propositions, but the computation 
rules are only necessary in the proof-relevant case.
% 
\begin{mathpar}
	\inferrule[$\Nat$-Form]
		{\wfctx{\Gamma}}
		{\tytm{\Gamma}{\Nat}{\Type_0}}
	\ilabel{inferrule:nat-form}
	\and
	\inferrule[Zero]
		{\wfctx{\Gamma}}
		{\tytmannotated{\Gamma}{\zero}{\Nat}{\Type_0}}
	\ilabel{inferrule:zero}
	\and
	\inferrule[Suc]
		{\tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\tytmannotated{\Gamma}{\suc{n}}{\Nat}{\Type_0}}
	\ilabel{inferrule:suc}
\end{mathpar}
\begin{mathpar}
	\inferrule[$\Nat$-Elim]
		{\tytm{\Gamma}{A}{\Fun{\Nat}{\Univ}}
			\\ \tytmannotated{\Gamma}{t_0}{A\ \zero}{\Univ}
			\\ \tytmannotated{\Gamma}{t_S}{\Depfun[n]{\Nat}{\Fun{A\ n}{A\ (\suc{n})}}}{\Univ}
			\\ \tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\tytmannotated{\Gamma}{\natrec{A}{t_0}{t_S}{n}}{A\ n}{\Univ}}
	\ilabel{inferrule:nat-elim}
\end{mathpar}
% 
\sideremark{Remark that rule~\nameref{inferrule:nat-elim} applies to both 
	proof relevant and proof irrelevant predicates, but the computation rules
	\nameref{inferrule:nat-elim-zero} and \nameref{inferrule:nat-elim-suc}
	only apply to proof relevant predicates. Reduction rules are pointless
	in the computationally irrelevant layer.}
% 
\begin{mathpar}
	\inferrule[$\Nat$-Elim-Zero]
		{\tytm{\Gamma}{A}{\Fun{\Nat}{\Type_i}}
			\\ \tytmannotated{\Gamma}{t_0}{A\ \zero}{\Type_i}
			\\ \tytmannotated{\Gamma}{t_S}{\Depfun[n]{\Nat}{\Fun{A\ n}{A\ (\suc{n})}}}{\Type_i}}
		{\redannotated{\Gamma}{\natrec{A}{t_0}{t_S}{\zero}}{t_0}{A\ 0}{\Type_i}}
	\ilabel{inferrule:nat-elim-zero}
\end{mathpar}
% 
\begin{mathpar}
	\inferrule[$\Nat$-Elim-Suc]
		{\tytm{\Gamma}{A}{\Fun{\Nat}{\Type_i}}
			\\ \tytmannotated{\Gamma}{t_0}{A\ \zero}{\Type_i}
			\\ \tytmannotated{\Gamma}{t_S}{\Depfun[n]{\Nat}{\Fun{A\ n}{A\ (\suc{n})}}}{\Type_i}
			\\ \tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\redannotated{\Gamma}{\natrec{A}{t_0}{t_S}{\suc{n}}}{t_S\ n\ \natrec{A}{t_0}{t_S}{n}}{A\ (\suc{n})}{\Type_i}}
	\ilabel{inferrule:nat-elim-suc}
\end{mathpar}

The observational equality between two natural numbers computes by recursively 
checking that their head constructors are compatible.
% 
If the comparison reaches \( \Obseq{\zero}{\zero} \), the equality type reduces 
to \( \Unit \), but in case it encounters two incompatible constructors, it
returns \( \Empty \).
% 
\begin{mathpar}
	\inferrule[Eq-zero]
		{\wfctx{\Gamma}}
		{\red{\Gamma}{\Obseq[\Nat]{\zero}{\zero}}{\Unit}{\sProp}}
	\ilabel{inferrule:eq-zero}
	\quad
	\inferrule[Eq-Suc]
		{\tytmannotated{\Gamma}{n}{\Nat}{\Type_0}
			\\ \tytmannotated{\Gamma}{m}{\Nat}{\Type_0}}
		{\red{\Gamma}{\Obseq[\Nat]{\suc{m}}{\suc{n}}}{\Obseq[\Nat]{m}{n}}{\sProp}}
	\ilabel{inferrule:eq-suc}
\end{mathpar}
\begin{mathpar}
	\inferrule[Eq-zero-suc]
		{\tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\red{\Gamma}{\Obseq[\Nat]{\zero}{\suc{n}}}{\Empty}{\sProp}}
	\ilabel{inferrule:eq-zero-suc}
	\quad
	\inferrule[Eq-suc-zero]
		{\tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\red{\Gamma}{\Obseq[\Nat]{\suc{n}}{\zero}}{\Empty}{\sProp}}
	\ilabel{inferrule:eq-suc-zero}
\end{mathpar}

\subsection{Universes}
\label{sec:universe}

\paragraph*{The Universe of Propositions}

The universe \( \sProp \) is a proof-relevant type of sort \( \Type_0 \).
Note that it is natural for this universe to be a proof-relevant type, since its inhabitants are
the propositions, which are not convertible to one another despite being proof-irrelevant.
% 
\begin{mathpar}
	\inferrule[Univ-Prop]
		{\wfctx{\Gamma}}
		{\tytm{\Gamma}{\sProp}{\Type_0}}
	\ilabel{inferrule:univ-prop}
\end{mathpar}

The observational equality between two inhabitants of \( \sProp \) reduces to
their logical equivalence, which bakes the principle of propositional 
extensionality into \SetoidCC.

\sideremark{Recall that the implication is a non-dependent proof-irrelevant
\( \Pi \)-type. Likewise, we define the conjunction as the non-dependent
case of the dependent conjunction.}
% 
\begin{mathpar}
	\inferrule[Eq-$\sProp{}$]
		{\tytm{\Gamma}{A}{\sProp}
			\\ \tytm{\Gamma}{B}{\sProp}}
		{\red{\Gamma}{\Obseq[{\sProp}]{A}{B}}{\Prod{(\Fun{A}{B})}{(\Fun{B}{A})}}{\sProp}}
	\ilabel{inferrule:eq-sprop}
\end{mathpar}

\paragraph*{The Universe Hierarchy of Proof-Relevant Types}
% 
\SetoidCC has a predicative hierarchy of proof-relevant universes.
\begin{mathpar}
	\inferrule[Univ-Rel]
		{\wfctx{\Gamma}}
		{\tytm{\Gamma}{\Type_i}{\Type_{i+1}}}
	\ilabel{inferrule:univ-prop}
\end{mathpar}

The observational equality on inhabitants of \( \Type \) computes by recursively
checking that the head constructors of the two types match. 
% 
For instance, two proof-relevant function types \( A \to B \) and \( A' \to B' \) 
are observationally equal exactly when \( \Obseq{A}{A'} \) and \( \Obseq{B}{B'} \).
% 
In case the head constructors do not match, the observational equality is false,
as enforced by the following rule. 
%  
\sideremark{Rule~\nameref{inferrule:eq-univ-noeq} is not strictly necessary.
We can drop it and get a system that works just as well, with slightly less 
control over the universe.}
\begin{mathpar}
	\inferrule[Eq-Univ-$\neq$]
		{\wfctx{\Gamma} \\ \head{A} \neq \head{B}}
		{\red{\Gamma}{\Obseq[{\Type}]{A}{B}}{\Empty}{\sProp}}
	\ilabel{inferrule:eq-univ-noeq}
\end{mathpar}
% 
The auxiliary function $\head{A}$ returns the head constructor of \( A \), 
including sort annotations. In particular, this means that the observational 
equality between a \( \Pi \)-type with a relevant domain and a \( \Pi \)-type
with an irrelevant domain reduces to \( \Empty \).

In the case the head constructors \emph{do} match, however, the behavior of the
observational equality needs to be specified with a rule for each constructor.
Here are the rules that handle the proof-relevant types that we described so far: 

\begin{mathpar}
	\inferrule[Eq-Univ]
		{\wfctx{\Gamma} \\ A \in \{ \Nat, \sProp, \Type_i \}}
		{\red{\Gamma}{\Obseq[{\Type}]{A}{A}}{\Unit}{\sProp}}
	\ilabel{inferrule:eq-univ}
\end{mathpar}
\begin{mathpar}
	\inferrule[Eq-$\Pi$]
		{\tytm{\Gamma}{A,A'}{\Univ}
			% \\ \tytm{\Gamma}{A'}{\Univ_i}
			\\ \tytm{\extctx{\Gamma}{A}}{B}{\Type_i}
			\\ \tytm{\extctx{\Gamma}{A'}}{B'}{\Type_i}
			\\ a := \cast{A'}{A}{e}{a'}}
		{\redmultiline{\Gamma}
			{\Obseq[\Type]{\Depfun{A}{B}}{\Depfun{A'}{B'}}}
			{\Exists[e]{\Obseq[{\Univ}]{A'}{A}}{\Depfun[a']{A'}{\Obseq[{\Type}]{\subst{B}{a}}{\subst{B'}{a'}}}}}{\sProp}}
	\ilabel{inferrule:eq-pi}
\end{mathpar}
\sideremark{Remark that the resulting types for \( \Pi \) and \( \Sigma \) are 
slightly different (but equivalent) propositions.
In each case, we picked the version that will result in a simpler reduction 
rule for \( \castName \) in the next section.}
\begin{mathpar}
	\inferrule[Eq-$\Sigma$]
	{\tytm{\Gamma}{A,A'}{\Univ}
	% \\ \tytm{\Gamma}{A'}{\Univ_i}
	\\ \tytm{\extctx{\Gamma}{A}}{B}{\Type_i}
	\\ \tytm{\extctx{\Gamma}{A'}}{B'}{\Type_i}
	\\ a' := \cast{A}{A'}{e}{a}}
{\redmultiline{\Gamma}
	{\Obseq[\Type]{\Depsum{A}{B}}{\Depsum{A'}{B'}}}
	{\Exists[e]{\Obseq[{\Univ}]{A}{A'}}{\Depfun[a]{A}{\Obseq[{\Type}]{\subst{B}{a}}{\subst{B'}{a'}}}}}{\sProp}}
	\ilabel{inferrule:eq-sigma}
\end{mathpar}

The first rule~\nameref{inferrule:eq-univ} says that the diagonal equalities on
the base type constructors are true.
The other two (\nameref{inferrule:eq-pi} and \nameref{inferrule:eq-sigma}) 
say that two dependent function (resp. sum) types are equal when their domain 
are equal, and their codomain are pointwise equal (as type families) up to the 
equality on their domain.
% 
Naturally, there are also rules for quotients, box types and the inductive 
equality, that we will describe after having introduced them.

\paragraph*{Reduction Rules for Cast}
% 
As we explained in \cref{sec:cast-intro}, the \( \castName \) operator is an
eliminator of the universe, which computes with a specific rule for each type.
% 
First, casting from $\Nat$ to $\Nat$ is defined by recursion.
\sideremark{We could instead define type-casting of natural numbers to be the identity, but we prefer
this definition because it can be generalized to more complex inductive types, such as lists.}
% 
\begin{mathpar}
	\inferrule[Cast-Zero]
		{\tytm{\Gamma}{e}{\Obseq[{\Type_0}]{\Nat}{\Nat}}}
		{\redannotated{\Gamma}{\cast{\Nat}{\Nat}{e}{\zero}}{\zero}{\Nat}{\Type_0}}
	\ilabel{inferrule:cast-zero}
\end{mathpar}
\begin{mathpar}
	\inferrule[Cast-Suc]
		{\tytm{\Gamma}{e}{\Obseq[{\Type_0}]{\Nat}{\Nat}}
			\\ \tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
		{\redannotated{\Gamma}{\cast{\Nat}{\Nat}{e}{\suc{n}}}{\suc{\cast{\Nat}{\Nat}{e}{n}}}{\Nat}{\Type_0}}
	\ilabel{inferrule:cast-suc}
\end{mathpar}

Casting a type from a universe to the same universe is the identity.
% 
\begin{mathpar}
	\inferrule[Cast-Univ]
		{\tytm{\Gamma}{e}{\Obseq[\Univ^+]{\Univ}{\Univ}}
			\\ \tytm{\Gamma}{A}{\Univ}}
		{\red{\Gamma}{\cast{\Univ}{\Univ}{e}{A}}{A}{\Univ}}
	\ilabel{inferrule:cast-univ}
\end{mathpar}
%
Casting between two dependent products is slightly more involved: it
produces a new function by casting back and forth the argument and return
value of the original function.
% 
\begin{figure*}[!h]
\begin{mathpar}
	\inferrule[Cast-$\Pi$]
		{\tytm{\Gamma}{e}{\Obseq[{\Type}]{\Depfun{A}{B}}{\Depfun{A'}{B'}}}
			\\ \tytmannotated{\Gamma}{f}{\Depfun{A}{B}}{\Type}
			\\ a := \cast{A'}{A}{\fst{e}}{a'}}
		{\redmultiline{\Gamma}
			{\cast{\Depfun{A}{B}}{\Depfun{A'}{B'}}{e}{f}}
			{\lam[a']{A'}{\cast{\subst{B}{a}}{\subst{B'}{a'}}{\snd{e}\ a'}{f\ a}}}
			{\Depfun{A'}{B'} : \Type_i}}
	\ilabel{inferrule:cast-pi}
\end{mathpar}
\end{figure*}

Finally, casting between two dependent sums produces a new dependent pair
by applying \( \castName \) to the projections of the original one.
% 
\begin{figure*}[!h]
\begin{mathpar}
	\inferrule[Cast-$\Sigma$]
		{\tytm{\Gamma}{e}{\Obseq[{\Type}]{\Depsum{A}{B}}{\Depsum{A'}{B'}}}
			\\ \tytmannotated{\Gamma}{t}{\Depsum{A}{B}}{\Type}
			\\ a' := \cast{A}{A'}{\fst{e}}{\relfst{t}}}
		{\redmultiline{\Gamma}
			{\cast{\Depsum{A}{B}}{\Depsum{A'}{B'}}{e}{t}}
			{\relpair{a'}{\cast{\subst{B}{\relfst{t}}}{\subst{B'}{a'}}{\snd{e}}{\relsnd{t}}}}
			{\Depsum{A'}{B'} : \Type_i}}
	\ilabel{inferrule:cast-sigma}
\end{mathpar}
\end{figure*}

We only define reduction rules when the two types have the same head, and in other
cases the cast will simply be a stuck term.
% 
Alternatively, we could reduce a cast between any two incompatible
types to \( {\color{RoyalBlue}\bot}\metaop{-elim} \) applied to the equality
proof, which has type $\Empty$ according to rule~\nameref{inferrule:eq-univ-noeq}.
This amounts to replacing a stuck term with another, so we do not bother.

\subsection{Quotients}

Quotients are a ubiquitous construction in mathematics, and one that
is famously difficult to handle smoothly in \MLTT.
%
The usual way to handle quotients is \textit{via} 
\defnote{setoids}{Recall that a setoid is a type \( A \) equipped with an 
equivalence relation, that plays the role of the equality of \( A \).}, 
but since this structure is not built in \MLTT, all the functions between
setoids, all the predicates, etc... have to be supplemented with
bureaucratic equality preservation lemmas.

In \SetoidCC however, every type is naturally a setoid (with the observational 
equality) and every term preserves the setoid equality by construction. 
This is a very comfortable setting for quotients, that can thus be added to the
theory---provided the relation that induces the quotient is proof-irrelevant.
%
This can be seen as a limitation, as noticed
by~\sidecitet{sterling_et_al:LIPIcs:2019:10538}, as it is generally
impossible to extract proof-relevant information from equality in
the quotient type. This is in contrast with the development of higher
inductive types in the cubical setting~\sidecite{10.1145/3209108.3209197}.
%
On the other hand, the positive consequence of this limitation is
that the elimination principle of the quotient types is fairly easy to
manipulate in \SetoidCC.

Quotient types are defined on a type \( A \) equipped with an
equivalence relation on \( A \).
\begin{mathpar}
  \inferrule[Quotient-Form]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{R}{\Fun{A}{\Fun{A}{\sProp}}}{\Type_i}
			\\ \tytmannotated{\Gamma}{R_r}{\Depfun{A}{R\ x\ x}}{\sProp}
			\\ \tytmannotated{\Gamma}{R_s}{\Depfun[x,y]{A}{\Fun{R\ x\ y}{R\ y\ x}}}{\sProp}
			\\ \tytmannotated{\Gamma}{R_t}{\Depfun[x,y,z]{A}{\Fun{R\ x\ y}{\Fun{R\ y\ z}{R\ x\ z}}}}{\sProp}}
			{\tytm{\Gamma}{\Quo{A}{(R,R_r,R_s,R_t)}}{\Type_i}}
\end{mathpar}
Since the proofs of reflexivity, symmetry and transitivity appear
everywhere but are proof-irrelevant, we will abreviate them as \( \mathsf{isrel}(R) \) in
the assumptions of the rules, and we write \( \Quo{A}{R} \) instead of
\( \Quo{A}{(R,R_r,R_s,R_t)} \).

The only constructor of quotient types is the canonical projection: from an element \( t \) of
\( A \), one obtains an element \( \quo{t} \) of \( \Quo{A}{R} \). Equality between
two canonical projections reduces to \( R \).
%
\begin{mathpar}
  \inferrule[Quotient-Proj]{\tytmannotated{\Gamma}{t}{A}{\Type_i}
  			\\ \tytmannotated{\Gamma}{R}{\Fun{A}{\Fun{A}{\sProp}}}{\Type_i}
			\\ \mathsf{isrel}(R)}
			{\tytmannotated{\Gamma}{\quo{t}}{\Quo{A}{R}}{\Type_i}}
  \and
  \inferrule[Quotient-Proj-Eq]{\tytmannotated{\Gamma}{t}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{u}{A}{\Type_i}
			\\ \tytmannotated{\Gamma}{R}{\Fun{A}{\Fun{A}{\sProp}}}{\Type_i}
			\\ \mathsf{isrel}(R)}
			{\red{\Gamma}{\Obseq[\Quo{A}{R}]{\quo{t}}{\quo{u}}}{R\ t\ u}{\sProp}}
\end{mathpar}
% 
Observational equality between two quotient types reduces to equality
of the (proof-relevant part of the) telescopes that define each
quotient:
% 
\sideremark{This rule is perhaps too fine compared to what we might hope for: 
plenty of isomorphic quotients are not identified. But remember that the 
observational equality between types is by no means univalent, and only identifies
types that have been constructed in the same way.
}
% 
\begin{mathpar}
  \inferrule[Quotient-Eq]{\tytm{\Gamma}{A}{\Type_i}
	\hspace{2em} \tytm{\Gamma}{R}{\Fun{A}{\Fun{A}{\sProp}}}
	\\ \mathsf{isrel}(R)
	\\ \tytm{\Gamma}{A'}{\Type_i}
	\\ \tytm{\Gamma}{R'}{\Fun{A'}{\Fun{A'}{\sProp}}}
	\\ \mathsf{isrel}(R')
	\\ x' :=  \cast{A}{A'}{e}{x}
	\\ y' :=  \cast{A}{A'}{e}{y}}
	{\redmultiline{\Gamma}{\Obseq[\Type]{\Quo{A}{R}}{\Quo{A'}{R'}}}
	  {\Exists[e]{\Obseq[\Type]{A}{A'}}
	  {\Depfun[x\ y]{A}
	  {\Obseq[\sProp]{R\ x\ y}{R\ x'\ y'}}}}{\sProp}}
\end{mathpar}
% 
Then, given a proof of equality between quotients, the $\castName$ operator 
reduces on canonical projections.
%
\begin{mathpar}
  \inferrule[Quotient-Proj-Cast]{\tytmannotated{\Gamma}{e}{\Obseq[\Type_i]{\Quo{A}{R}}{\Quo{A'}{R'}}}{\sProp}
	\\ \tytmannotated{\Gamma}{t}{A}{\Type_i}}
  {\redannotated{\Gamma}{\cast{\Quo{A}{R}}{\Quo{A'}{R'}}{e}{\quo{t}}}{\quo{\cast{A}{A'}{\fst{e}}{t}}}{\Quo{A}{R'}}{\Type_i}}
\end{mathpar}
 
The eliminator for quotient types encodes the universal property of quotients: to construct a
function out of a quotient \( \Quo{A}{R} \), it suffices to give a function \( t_\pi \) out of \( A \)
such that if \( R \ x \ y \), then their images under \( t_\pi \) are equal.
% 
\begin{figure*}[!h]
\begin{mathpar}
  \inferrule[Quotient-Elim]{\tytm{\Gamma}{B}{\Fun{\Quo{A}{R}}{\Univ}}
			\\ \tytm{\Gamma}{t_\pi}{\Depfun{A}{B\ \quo{x}}}
			\\ \tytm{\Gamma}{t_\sim}{\Depfun[x,y]{A}{\Depfun[e]{R\ x\ y}{\Obseq[B\ \quo{x}]{(t_\pi\ x)}{\cast{B\ \quo{y}}{B\ \quo{x}}{B\ \sym{e}}{t_\pi\ y}}}}}
			\\ \tytm{\Gamma}{u}{\Quo{A}{R}}}
			{\tytmannotated{\Gamma}{\quorec{B}{t_\pi}{t_\sim}{u}}{B\ u}{\Univ}}
\end{mathpar}
\end{figure*}

The eliminator for quotient types has the obvious computation rule
% 
\begin{figure*}[!h]
\begin{mathpar}
  \inferrule[Quotient-Proj-Elim]{\tytm{\Gamma}{B}{\Fun{\Quo{A}{R}}{\Type_i}}
			\\ \tytm{\Gamma}{t_\pi}{\Depfun{A}{B\ \quo{x}}}
			\\ \tytm{\Gamma}{t_\sim}{\Depfun[x,y]{A}{\Depfun[e]{R\ x\ y}{\Obseq[B\ \quo{x}]{(t_\pi\ x)}{\cast{B\ \quo{y}}{B\ \quo{x}}{B\ \sym{e}}{t_\pi\ y}}}}}
			\\ \tytm{\Gamma}{u}{A}}
			{\redannotated{\Gamma}{\quorec{B}{t_\pi}{t_\sim}{\quo{u}}}{t_\pi\ u}{B\ (\quo{u})}{\Type_i}}
\end{mathpar}
\end{figure*}

On top of this, quotients also come with the appropriate substitution and 
congruence rules.
% ifAppendix{ as defined in \cref{fig:SetoidTT-substitution,fig:SetoidTT-congruence}}

\subsection{Squash and Box Types}

\paragraph*{Squash Types}

The \emph{squash}, or propositional truncation type former embeds the 
proof-relevant types into the proof-irrelevant world.
% 
Given a proof-relevant type \( A \), its truncated version \( \Squash{A} \) is a
proposition that forgets all the computational information of inhabitants of
\( A \) and only retains their mere existence.
% 
The squash type constructor is defined \textit{via} an impredicative encoding.
\[
	\Squash{A} \quad := \quad \Depfun[X]{\sProp}{\Fun{(\Fun{A}{X})}{X}}
\]
Given an inhabitant \( t \) of \( A \), we can give a proof of \( \Squash{A} \)
with a simple lambda-term: 
\[
	\squash{t} \quad := \quad \lambda\ X\ H\ .\ H\ t \quad : \quad \Squash{A}
\]

The propositional truncation of \SetoidCC is reminiscent of the
propositional truncation used in Homotopy Type Theory, but the eliminator
is much less flexible.
% 
Indeed, in \HoTT the propositional truncation may be eliminated into any type 
\( A \), provided we can show that all the inhabitants of \( A \) are 
propositionally equal.
% 
But in \SetoidCC, propositions are \emph{strict}, meaning that being a 
proposition is about the definitional equality and not the propositional 
equality. 
% 
Thus the eliminator would ideally apply to any type whose inhabitants are 
all convertible---but since we cannot reason internally about the definitional
equality, we restrict elimination to types of sort \( \sProp \).

\paragraph*{Box Types}
% 
Conversely, Box types embed the propositions into the proof-relevant world.
They are useful for a number of constructions: for instance, from a type \( \tm{A}{\Type_i} \) and a
proof-irrelevant predicate \( \tm{P}{\Fun{A}{\sProp}} \), one can build a \emph{subset type}
\( \tm{\Sig{A}{\Boxt{(P\ x)}}}{\Type_i} \) whose inhabitants come with a proof of \( P \), but
retain the computational behavior of inhabitants of \( A \).

Another typical use of $\Boxt{}$ is to define a singleton
  type on which it is possible to reason about equality. Indeed, although
  $\Unit$ has only one inhabitant up-to conversion, it is not possible
  to state this internally as equality between proofs of propositions is not defined.
  %
  However, one can state contractibility of the type $\Boxt{\Unit}$ and prove
  it, as it lives in $\Type$.

Box types can be defined with the following rules:
% 
\begin{mathpar}
  \inferrule[Box-Form]{\tytm{\Gamma}{A}{\sProp}}
			{\tytm{\Gamma}{\Boxt{A}}{\Type_0}}
  \and
  \inferrule[Box-Proof]{\tytmannotated{\Gamma}{t}{A}{\sProp}}
			{\tytmannotated{\Gamma}{\boxt{t}}{\Boxt{A}}{\Type_0}}
  \and
  \inferrule[Box-Proof-Eq]{\tytmannotated{\Gamma}{t,u}{\Boxt{A}}{\Type_0}}
			{\red{\Gamma}{\Obseq[\Boxt{A}]{t}{u}}{\Unit}{\sProp}}
\end{mathpar}
\begin{mathpar}
  \inferrule[Unbox]{\tytm{\Gamma}{A}{\sProp}
			\\ \tytm{\Gamma}{t}{\Boxt{A}}}
			{\tytm{\Gamma}{\unboxt{t}}{A}}
  \and
  \inferrule[Box-Eq]{\tytm{\Gamma}{A,B}{\sProp}}
			{\red{\Gamma}
			  {\Obseq[\Type]{\Boxt{A}}{\Boxt{B}}}
			  {\Obseq[\sProp]{A}{B}}
			  {\sProp}}
\end{mathpar}
\begin{mathpar}
  \inferrule[Box-Proof-Cast]{\tytm{\Gamma}{A, B}{\sProp}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{e}{\Obseq[\Type]{\Boxt{A}}{\Boxt{B}}}}
			{\red{\Gamma}{\cast{\Boxt{A}}{\Boxt{B}}{e}{\boxt{t}}}{\boxt{\cast{A}{B}{e}{t}}}{\Boxt{B}}}
\end{mathpar}

\subsection{The Inductive Equality}
\label{sec:inductive-equality}

\paragraph*{The J Eliminator for the Observational Equality}
% 
The reader may wonder if \SetoidCC extends Martin-Löf type theory---
that is, whether a judgment of \MLTT is also a judgment in the proof-relevant
fragment of \SetoidCC. 
% 
Indeed, our rules handle the universe hierarchy, dependent products, dependent
sums and the natural numbers in the exact same way. 
But there are some difficulties with the Martin-Löf identity type.

The first idea that might come to the reader's mind is to use the observational 
equality of \SetoidCC to interpret the inductive equality of \MLTT. 
Surely, proof irrelevance will provide us with more definitional equalities 
than what we need!
% 
For this plan to work, we need to derive the \( J \) eliminator for the
observational equality. It is not too difficult to come up with a term that
satisfies the same typing rule: 
\begin{mathpar}
  \inferrule{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{B}{\Depfun{A}{\Fun{\Obseq[A]{t}{x}}{\Univ}}}
			\\ \tytm{\Gamma}{b}{B\ t\ \refl{t}{A}}
			\\ \tytm{\Gamma}{t'}{A}
			\\ \tytm{\Gamma}{e}{\Obseq[A]{t}{t'}}}
			{\tytm{\Gamma}{\cast{B\ t\ \refl{t}{A}}{B\ t'\ e}{\eqJ{A}{t}{B}{t'}{e}}{b}}{B\ t'\ e}}
\end{mathpar}
where the auxiliary operator \( \metaop{eq}_{\metaop{J}} \) is defined by
% 
\sideremark{Remark that definitional proof irrelevance plays a role in the
	construction of \( \metaop{eq}_{\metaop{J}} \): the fourth argument of
	the \( \metaop{transp} \) operator is
	only well-typed when \( \metaop{refl} \) is convertible to any other
	proof of equality between \( t \) and itself.}
% 
\[
\begin{array}{rcl}
	\eqJ{A}{t}{B}{t'\!}{e} & \!:\! & \Obseq{B\ t\ \refl{t}{}}{B\ t'\ e} \\
	\eqJ{A}{t}{B}{t'\!}{e} & \!:=\! & \metaop{transp}({A}, {t}, 
    {\lambda\ x\ .\ {\Depfun[e'\!]{\Obseq{t}{x}}{\Obseq{B\ t\ \refl{t}{t}}{B\ x\ e'\!}}}}, \\ 
    & & \phantom{\metaop{transp}(}{\lambda\ e' .\ \metaop{refl}}, {t'}, {e})\ e.
\end{array}
\]

There is however a discrepancy with the computation rule of the \( J \) 
eliminator. In \MLTT, applying \( J \) to a proof of reflexivity is 
definitionally equal to the fourth argument:
\[
	\J{A}{t}{P}{u}{t}{\refl{t}{t}} \ \equiv \ u
\]
but in \SetoidCC with our replacement for \( J \), this definitional equality 
is weakened to a propositional equality in general---it might hold by 
definition when \( P \) is a closed term, but it certainly will not if \( P \) 
is a variable. 
% 
This is not a huge deal, as a theory with weakened computation rules still proves
the exact same theorems in presence of UIP and funext \sidecite{weaktt},
but it is an obstacle to a direct translation from \MLTT to \SetoidCC.

\paragraph*{The Inductive Equality in \SetoidCC}
% 
A very similar problem was encountered by \sidecitet{cubicaltt} in Cubical Type 
Theory when trying to interpret the Martin-Löf identity type as the cubical path 
type, and was solved by \sidecitet{Swan_2016}.
% 
Following his ideas, we extend \SetoidCC with \( \metaop{Id} \)-types:
% 
\begin{mathpar}
  \inferrule[Id-Form]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{u}{A}}
			{\tytm{\Gamma}{\Id{A}{t}{u}}{\Type_i}}
  \and
  \inferrule[Idrefl]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}}
			{\tytm{\Gamma}{\id{t}}{\Id{A}{t}{t}}}
\end{mathpar}
\begin{mathpar}
  \inferrule[Id-Proof-Eq]{\tytm{\Gamma}{e,e'}{\Id{A}{t}{u}}}
			{\red{\Gamma}{\Obseq[\Id{A}{t}{u}]{e}{e'}}{\Unit}{\sProp}}
\end{mathpar}
\begin{mathpar}
  \inferrule[J]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{B}{\Depfun{A}{\Fun{\Id{A}{t}{x}}{\Univ}}}
			\\ \tytm{\Gamma}{u}{B\ t\ \id{t}}
			\\ \tytm{\Gamma}{t'}{A}
			\\ \tytm{\Gamma}{e}{\Id{A}{t}{t'}}}
			{\tytm{\Gamma}{\J{A}{t}{B}{u}{t'}{e}}{B\ t'\ e}}
\end{mathpar}
\begin{mathpar}
  \inferrule[J-Idrefl]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{B}{\Depfun{A}{\Fun{\Id{A}{t}{x}}{\Type_j}}}
			\\ \tytm{\Gamma}{u}{B\ t\ \id{t}}}
			{\red{\Gamma}{\J{A}{t}{B}{u}{t}{\id{t}}}{u}{B\ t\ \id{t}}}
\end{mathpar}
% 
These rules mimic the behavior of Martin-Löf identity types, quotiented so they 
contain only one inhabitant up to observational equality. Let's see how we
could extend the operations of \SetoidCC to this new type former.

Firstly, we define the observational equality between two identity types as 
the equality of the telescopes of arguments, like we did for the quotient type:
%
\begin{mathpar}
  \inferrule[Id-Eq]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{u}{A}
			\\ \tytm{\Gamma}{A'}{\Type_i}
			\\ \tytm{\Gamma}{t'}{A'}
			\\ \tytm{\Gamma}{u'}{A'}}
			{\redmultiline{\Gamma}
			  {\Obseq[\Type]{\Id{A}{t}{u}}{\Id{A'}{t'}{u'}}}
			  {\Exists[e]{\Obseq[\Type]{A}{A'}}{\Prod{\Obseq[A']{\cast{A}{A'}{e}{t}}{t'}}{\Obseq[A']{\cast{A}{A'}{e}{u}}{u'}}}}
			  {\sProp}}
\end{mathpar}
%
Next, we may hope to define computation
rules for cast by simply reducing the equality proof to a weak head normal form, and then
commuting cast with the head constructor like we did for the type of natural numbers. 
However, we quickly run into a problem:
% 
\begin{mathpar}
  \inferrule{\tytm{\Gamma}{A, A'}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{t,u}{A'}
			\\ \tytm{\Gamma}{e}{\Obseq{\Id{A}{t}{t}}{\Id{A'}{t'}{u'}}}}
			{\red{\Gamma}{\cast{\Id{A}{t}{t}}{\Id{A'}{t'}{u'}}{e}{\id{t}}}{\ ?}{\Id{A'}{t'}{u'}}}
\end{mathpar}
% 
We cannot reduce this term to $\metaop{Idrefl}$, because \( t' \) and \( u' \)
are not convertible in general---\( e \) only provides us with a propositional 
equality \( \Obseq[A']{t'}{u'} \). 
% 
So in order to fix this, we add a new operator $\idpath{e} $ that turns any inhabitant of 
\( \Obseq[A]{t}{u} \) into an inhabitant of \( \Id{A}{t}{u} \).
% 
\begin{mathpar}
  \inferrule[Idpath]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{u}{A}
			\\ \tytm{\Gamma}{e}{\Obseq[A]{t}{u}}}
			{\tytm{\Gamma}{\idpath{e}}{\Id{A}{t}{u}}}
\end{mathpar}
%
Now we can define the computation rule for cast on $\id{t}$, using our new operator:
%
\begin{mathpar}
  \inferrule[Cast-Idrefl]{\tytm{\Gamma}{A, A'}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{t',u'}{A'}
			\\ \tytm{\Gamma}{e}{\Obseq{\Id{A}{t}{t}}{\Id{A'}{t'}{u'}}}}
			{\redmultiline{\Gamma}
			  {\cast{\Id{A}{t}{t}}{\Id{A'}{t'}{u'}}{e}{\id{t}}}
			  {\idpath{\transitivity{\sym{\fst{\snd{e}}}}{\snd{\snd{e}}}}}
			  {\Id{A'}{t'}{u'}}}
\end{mathpar}
% 
And naturally, we need to account for this additional constructor in the reduction 
rules for the observational equality and type-casting:
% 
\begin{figure*}[!h]
\begin{mathpar}
  \inferrule[J-Idpath]{\tytm{\Gamma}{A}{\Type_i}
			\\ \tytm{\Gamma}{t}{A}
			\\ \tytm{\Gamma}{B}{\Depfun{A}{\Fun{\Id{A}{t}{x}}{\Type_j}}}
			\\ \tytm{\Gamma}{b}{B\ t\ \id{t}}
			\\ \tytm{\Gamma}{t'}{A}
			\\ \tytm{\Gamma}{e}{\Obseq[A]{t}{t'}}}
			{\redmultiline{\Gamma}
			  {\J{A}{t}{B}{b}{t'}{\idpath{e}}}
			  {\cast{B\ t\ \id{t}}{B\ t'\ \idpath{e}}{\eqJ{A}{t}{B}{t'}{e} }{b}}
			  {B\ t'\ \idpath{e}}}
\end{mathpar}
\begin{mathpar}
  \inferrule[Cast-Idpath]{\tytm{\Gamma}{A, A'}{\Type_i}
			\\ \tytm{\Gamma}{t, u}{A}
			\\ \tytm{\Gamma}{e}{\Obseq[A]{t}{u}}
			\\ \tytm{\Gamma}{t',u'}{A'}
			\\\tytm{\Gamma}{e'}{\Obseq{\Id{A}{t}{t}}{\Id{A'}{t'}{u'}}}}
			{\redmultiline{\Gamma}
			  {\cast{\Id{A}{t}{u}}{\Id{A'}{t'}{u'}}{e'}{\idpath{e}}}
			  {\idpath{\transitivity{\transitivity{\sym{\fst{\snd{e'}}}}{\ap{(\cast{A}{A'}{\fst{e'}}{-})}{e}}}{\snd{\snd{e'}}}}}
			  {\Id{A'}{t'}{u'}}}
\end{mathpar}
\end{figure*}

With this handful of additional rules, our \( \metaop{Id} \) types satisfy all 
the computational rules of the Martin-Löf identity types. 
% 
Using these, we can complete our embedding of \MLTT into the proof-relevant 
layer of \SetoidCC.

\paragraph{Relation with the Observational Equality}
% 
The \( \metaop{Id} \) type is logically equivalent to the observational 
equality: 
% 
in one direction, the constructor $\metaop{IdPath}$ proves that 
\( \Obseq[A]{t}{u} \) implies \( \Id{A}{t}{u} \), and in the other direction
we can get a proof of observational equality from an inhabitant of 
\( \Id{A}{t}{u} \) by using the \( \metaop{J} \) eliminator. 
% 
In particular, this means that the principles of uniqueness of identity 
proofs, of function extensionality and of propositional extensionality are
derivable for the inductive equality, in stark contrast with Martin-Löf
type theory.

Thus, the only difference between the two equalities is a tradeoff between
definitional and propositional equations:
\sideremark{In \cref{ch:extensions}, we explain how to modify \SetoidCC
to get the best of both worlds: an observational equality that satisfies 
both UIP and the computation of \( J \). 
% But the normalization of this system is only conjectured.
}
% 
\begin{itemize}
\item The observational equality satisfies UIP by definition, but the \( J \) eliminator
applied to reflexivity only satisfies its computation rule up to propositional equality.
\item \( \metaop{Id} \) has a \( J \) eliminator that computes on reflexivity, but
it only satisfies UIP up to a propositional equality.
\end{itemize}

\subsection{Weak-head Reduction}
\label{sec:weak-head}

All the rules that we enunciated so far provide us with a complete description 
of the typing discipline and of the definitional equality of \SetoidCC. But our 
reduction rules are still incomplete.

Indeed, so far we have only defined reduction rules for redexes consisting of an 
eliminator applied to a constructor. 
% 
\sideremark{In the case of rule \cref{inferrule:beta-red}, the application is
considered as an eliminator, and the lambda-abstraction as a constructor.}
% 
To complete our reduction rules into a proper evaluation strategy, we need to 
define a class of \emph{normal forms} and add the necessary rules to evaluate 
an arbitrary program down to a normal form. 
% 
To this end, we introduce the notions of constructors, destructors and 
scrutinees.

Constructors are all those tokens that are introduced by introduction rules,
including \( \zero \) and \( \metaop{S} \) but also type formers (except for the
observational equality) and lambda-abstractions.

On the other hand, eliminators are introduced by elimination rules, and they
include tokens like \( \color{RoyalBlue}{\Nat}\metaop{-elim} \) but also 
applications, \( \castName \) or the observational equality type.
% 
An argument of an eliminator is said to be a \emph{scrutinee} when it may 
trigger a computation rule if it contains a term with a constructor in head 
position. 
% 
Note that an eliminator might have several scrutinees, for instance in 
\( \cast{A}{B}{e}{t} \) both \( A \) and \( B \) are scrutinees.

Now we can describe our evaluation strategy. We use a typed, deterministic 
\emph{weak head} reduction: 
\begin{itemize}
\item If a term has a constructor or a variable in head position, then it is a 
	weak head normal form, and does not reduce further.
\item If a term has an eliminator in head position, we reduce all the scrutinees 
	of that eliminator down to normal form. Then, if all the scrutinees have a 
	constructor in head position, we simplify the redex and restart the reduction process 
	on the result. Otherwise, we have a weak head normal form.
\end{itemize} 

In particular, we never reduce under a constructor, hence the name ``weak head''.
% 
The substitution rules that implement reduction of scrutinees to weak-head normal
form are described in appendix \ref{sec:ap:subst}.

The normal forms for our weak head reduction strategy are the \emph{weak head normal forms} 
(whnfs), defined in \cref{fig:whnf-neutral}. 
% 
A whnf is either a term with a constructor in head position, or a \emph{neutral term},
\ie a term that cannot be reduced to a normal form because it is stuck on a
variable, a proof of \( \Empty \) or a cast along a non-diagonal equality.
%
In \SetoidCC, inhabitants of a proof-irrelevant type are never
considered as whnf, as there is no notion of reduction of
proof-irrelevant terms.

\begin{figure}
  \begin{small}
	\[
	\begin{array}{l@{\qquad}lcl}
	\whnf	& w & ::=	& \neu \\
			&	& \sep	& \Type_i \qsep \sProp \qsep \Nat \qsep \Empty \qsep \Depfun{A}{B} \qsep \Depsum{A}{B} 
						\qsep \Quo{A}{R} \qsep \Boxt{A} \qsep \Id{A}{t}{u} \\
			&	& \sep	& \zero \qsep \suc{t} \qsep \lam{A}{t} \qsep \relpair{t}{u}
						\qsep \quo{t} \qsep \boxt{t} \qsep \id{t} \qsep \idpath{e} \\
	\neutral	& \neu	& ::=	& x \\
				&		& \sep 	& \neu~t \qsep \relfst{\neu} \qsep \relsnd{\neu} 
								\qsep \emptyrec{A}{e} \\   
				&		& \sep 	& \natrec{P}{t}{u}{\neu} \qsep \quorec{P}{t}{e}{\neu} \qsep \J{A}{t}{P}{u}{\neu}{e} \\  
				&		& \sep	& \Obseq[\neu]{t}{u} \\
				&		& \sep	& \Obseq[\Nat]{\neu}{m} \qsep \Obseq[\Nat]{\zero}{\neu}
								\qsep \Obseq[\Nat]{\suc{m}}{\neu} \\ 
				&		& \sep	& \Obseq[\Quo{A}{R}]{\neu}{t} \qsep \Obseq[\Quo{A}{R}]{\quo{t}}{\neu} \\
				&		& \sep	& \Obseq[{\Type_i}]{\neu}{A}
								\qsep \Obseq[{\Type_i}]{w}{\neu} \\ 
				&		& \sep	& \cast{\neu}{A}{e}{t} 
								\qsep \cast{w}{\neu}{e}{t} \\
				&		& \sep	& \cast{\Nat}{\Nat}{e}{\neu}
								\qsep \cast{\Quo{A}{R}}{\Quo{A'}{R'}}{e}{\neu} \\
				&		& \sep	& \cast{w}{w'}{e}{t}
												 \hspace{3em} \mbox{(where $\head{w} \neq
												 \head{w'}$)}
	\end{array}
  \]
  \end{small}
  \caption{Weak-head normal and neutral forms}
  \label{fig:whnf-neutral}
\end{figure}
\label{sec:examples}

\section{Overview of the Meta-Theory}
\label{sec:properties}

\subsection{Properties of \SetoidCC}

In order for a type theory to be a reasonable candidate for implementation 
in a proof assistant, it is desirable to have some amount of control over its 
behavior and its semantics.
% 
There is a wide variety of properties we can ask of a type theory, but in this 
section we will focus our attention on four important properties: consistency,
normalization, canonicity and decidability. 
% 
All the theorems of this section will be proved in \cref{ch:metatheory}.

\begin{theorem}[Consistency]
	In the empty context, there is no proof of \( \Empty \).
\end{theorem}

Our system is consistent in the sense that it is impossible to use it to derive a contradiction. It goes
without saying that this property is of utmost importance if one wants to build interesting
mathematics. 
% 
When proving a theory consistent, one should pay some attention to the meta-theory
where reasoning takes place, as a consistency result is really a reduction of the consistency of
the theory to the consistency of the meta-theory.

\begin{theorem}[Normalization]
	If the judgment \( \tytmannotated{\Gamma}{t}{A}{\Type_i} \) is derivable,
	then the weak-head reduction procedure applied to \( t \) eventually 
	reaches a weak-head normal form.

	By recursively applying the weak-head normalization to the subterms of 
	\( t \), we eventually reach a deep normal form.
\end{theorem}

The adjective \emph{normal} deserves a bit of discussion. 
% 
Ideally, the normal form of a term should be a distinguished representative 
of its equivalence class under convertibility---and thus any two convertible 
terms should have the same normal form, so that checking convertibility is reduced
to comparing the normal forms.
% 
However our deep reduction strategy does not \( \eta \)-expand/reduce
terms, meaning that normal forms are only unique up to \( \eta \)-equivalence.
This is not too much of an issue, since \( \eta \)-equivalence of \( \beta \)-normal 
well-typed terms is easy to decide---we just put them in \( \eta \)-long form.

\begin{theorem}[Canonicity of \( \Nat \)]
	If a term \( t \) has type \( \Nat \) in the empty context, then there 
	exists an external integer \( n \) such that \( t \) is 
	convertible with \( \metaop{S}^n\ \zero \).
\end{theorem}

A term belonging to a type is called canonical when it can be explicitly built up
using the constructors of that type. For instance, an inhabitant of the type \( \Nat \) of natural
numbers is canonical if it is an explicit numeral. If all terms of type \( \Nat \) in an empty
context normalize to a canonical form, then the theory is said to enjoy canonicity for natural
numbers.

Together with normalization, canonicity gives a computational justification of
constructiveness: 
% 
provided a closed witness of the type \( \Depsum[n]{\Nat}{P\ n} \), we can take 
its first projection and normalize it to recover a concrete integer \( n \) that 
satisfies \( P \).
% 
Thus, proving a theorem truly does amount to giving an explicit construction of a 
witness.
% 
Note however that this is only true in the proof-relevant layer of \SetoidCC, as 
there is no computational content to extract from a proof of 
\( \Exists[n]{\Nat}{P\ n} \).

\begin{theorem}[Decidability]
	There is an algorithm that decides whether any two terms \( t \) and 
	\( u \) that have type \( A \) in context \( \Gamma \) are convertible 
	or not.

	There is an algorithm that, given a context \( \Gamma \), a term \( t \), 
	a type \( A \) and a sort \( \Univ \), decides whether the judgment 
	\( \tytmannotated{\Gamma}{t}{A}{\Univ} \) is derivable.
\end{theorem}

Finally, in order to implement a type theory in a proof assistant, it is desirable to have an
algorithm that, given a context \( \Gamma \) and terms \( t \) and \( A \), decides whether \( t \)
is an inhabitant of \( A \) in context \( \Gamma \). This ensures users that when they find a
proof for a statement, the proof assistant can automatically check that their proof is correct.

\subsection{Comparing \SetoidCC with Martin-Löf Type Theory}
 
The proof-relevant layer of \SetoidCC supports all the basic types of Martin-Löf 
type theory: a universe hierarchy, dependent products, dependent sums, the natural 
numbers, and the inductive equality; furthermore all the computation rules that 
these types satisfy in \MLTT still hold true in \SetoidCC.
% 
Thus, we can embed this minimalistic version of \MLTT into our system.

\begin{theorem}[Embedding]
	If the judgment \( \tytm{\Gamma}{t}{A} \) is derivable in \MLTT, then
	we can find an integer \( i \) such that \( \tytmannotated{\Gamma}{t}{A}{\Type_i} \)
	is derivable in \SetoidCC. 
\end{theorem} 

Of course, \SetoidCC is not 
\defnote{conservative}{An extension \( \mathcal{T}' \) of a theory 
\( \mathcal{T} \) is said to be conservative when it proves no new
theorems that can be stated in \( \mathcal{T} \)} 
over \MLTT, as it is possible to prove function extensionality 
and UIP for the inductive equality.
% 
Still, there is a precise sense in which \SetoidCC does not offer more
computational power than \MLTT. 

\begin{theorem}[Computational power]
	Any function that can be expressed as a term of type \( \Nat \to \Nat \)
	in \SetoidCC can be expressed as a term of type \( \Nat \to \Nat \) in
	\MLTT.
\end{theorem}

This may come as a surprise, because \SetoidCC is impredicative, and thus
should be much more powerful than a predicative theory such as \MLTT. 
% 
Well, in a way, it is! The impredicativity allows us to prove the existence
of functions that grow much faster than what is definable in \MLTT. But there is
a catch: we can only prove their existence in the proof-irrelevant layer, and
we have no way to extract them to actual functions of type \( \Nat \to \Nat \).
We will discuss this in more detail in \cref{ch:extensions}.

\subsection{Semantics of \SetoidCC}

Because of the observational equality and the impredicative universe of 
propositions, types in \SetoidCC feel a lot more ``set-like'' than types
in Martin-Löf type theory: functions are extensional, equality 
proofs are unique, we can build quotients and subtypes, \textit{etc}.
% 
Thus, it does not come as a surprise that we can interpret proofs in 
\SetoidCC as talking about classical sets.

\begin{theorem}
	\SetoidCC has a model in classical set theory, in which the universe
	hierarchy contains codes for all ZF sets.
\end{theorem}

But \SetoidCC is also constructive, \ie the principle of excluded middle
does not hold. 
% 
This incites us to investigate more general classes of models, that do not 
collapse the propositions to a two-valued set. 
% 
Now, there happens to be an important class of categories that share most
properties of the category of sets but not excluded middle, called 
\emph{Grothendieck toposes}. 
% 
And indeed, Gratzer showed that \SetoidCC has models in all Grothendieck 
toposes~\sidecite{https://doi.org/10.48550/arxiv.2202.05529}.

This makes \SetoidCC a reasonably good language to reason internally to a 
Grothendieck topos. 
However, \SetoidCC does not validate all the reasoning principles that are
available in the logic of toposes. In particular, the most glaring omission is the
principle of unique choice, which states that given any relation 
\( R : A \to B \to \sProp \) we can build a choice function if we know that \( R \)
is the graph of a functional relation.
\sideremark{The unique existence quantifier \( {\ExistsUnique{A}{P\ x}} \) is defined as
the following proposition:\\
\( {\varExists{A}{(P\ x \land \Pi\ y\ .\ {P\ y \to \Obseq{x}{y}})}}. \)}
% 
\[
	\Depfun{A}{\ExistsUnique[y]{B}{R\ x\ y}} \quad \to \quad \Depsum[f]{\Fun{A}{B}}{\Depfun{A}{R\ x\ (f\ x)}}.
\]

With this, we conclude our overview of the Observational Calculus of 
Constructions and we turn to the next chapter, in which we will develop the
tools that are needed to prove the various theorems that we enunciated.

% The principle of \emph{unique choice} states that functions are the same
% as graphs: given a relation \( R \) on \( A \times B \) that associates
% exactly one element of \( B \) to any given element of \( A \), we can
% construct a function \( f : A \to B \) which picks that element: 
% \sideremark{The unique existence quantifier \( \ExistsUnique{A}{P\ x} \) is defined as
% the following conjunction:
% \( {\Exists{A}{P\ x}} \land {\Depfun[x,y]{A}{P\ x \to P\ y \to \Obseq{x}{y}}}. \)}
% % 
% \[
% 	\Depfun{A}{\ExistsUnique[y]{B}{R\ x\ y}} \quad \to \quad \Depsum[f]{\Fun{A}{B}}{\Depfun{A}{R\ x\ (f\ x)}}.
% \]
% This principle is available in the theory of elementary toposes if we interpret
% \( \sProp \) as the subobject classifier

% Unfortunately, this principle is not provable in \SetoidCC, because we have
% no way to extract the proof-relevant information necessary to build \( f \)
% from a proof-irrelevant existential.

% However, it becomes trivially provable if we replace the unique existence 
% quantifier with a dependent sum.

% \section{Related work}

% Compared to~\sidecite{altenkirchAl:plpv2007}, the most important ingredient in \SetoidTT is the
% use of definitional proof-irrelevance.
% %
% This added flexibility in computations allows our recursors to enjoy proper computational
% behavior on open terms, and it also lets us seamlessly treat universe hierarchies.
% %
% Moreover, the normalization proof for OTT relies on a normalization conjecture for a different
% theory, unlike the normalization proof for \SetoidTT.

% In~\sidecite{Altenkirch2019}, the authors define a setoid model in \( \MLTT+\sProp \). Then, they
% interpret a version of \MLTT with proof-irrelevant identity types that support propext and
% funext in their model, thereby providing a computational interpretation of these principles.
% %
% However, handling universes in their model requires some additions to \( \MLTT+\sProp \), and
% the resulting theory is only conjectured to be normalizing.
% %
% In contrast to this, \SetoidTT is a full-fledged type theory and does not require any external
% model to compute.

% Compared to XTT~\sidecite{sterling_et_al:LIPIcs:2019:10538}, the strengths of \SetoidTT are a
% normalization strategy that exhibits canonicity, as well a full proof that conversion and typing
% are decidable. These properties allow us to present a concrete implementation of our system
% in a proof assistant.
% %
% In XTT however, Sterling\etal show that typing cannot be decidable, as there is no way to deduce
% \( \Obseq{A}{A'} \) and \( \Obseq{B}{B'} \) from a proof of \( \Obseq{A \times B}{A' \times B'} \).
% %
% In order to fix this shortcoming, they suggest adding a ``typecase'' operator, but
% argue against it since it forces the universe to be closed, thereby severely constraining the
% possible semantics.
% %
% In \SetoidTT, we obtain the injectivity of type contructors from the behavior of observational
% equality in the universe. These rules somewhat constrain the semantics---for instance, we cannot
% interpret \SetoidTT in set theory using a Grothendieck universe as the interpretation of \( \Type \)
% ---but our universe remains open to the addition of arbitrary types.