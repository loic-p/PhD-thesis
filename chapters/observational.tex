\setchapterimage[6cm]{seaside}
\setchapterpreamble[u]{\margintoc}
\chapter{The Observational Calculus of Constructions}
\labch{layout}
\label{sec:type-theory-with}

% \sideremark{The \SetoidCC acronym stands for the ``Observational Calculus of 
% Constructions''.}
In this chapter we present our system \SetoidCC, which is a flavor of 
Altenkirch and McBride's observational type theory \cite{altenkirchAl:plpv2007}.
% 
\SetoidCC extends Martin-Löf Type Theory with support for an observational 
equality, impredicative propositions, and quotient types while preserving the
computational properties of \MLTT (see \cref{ch:metatheory}).

We start in \cref{sec:generalities} with some generalities about the system, then we delve 
into a detailed description of the typing rules in \cref{sec:typing-rules}, and 
finally we conclude with a few examples that showcase the new features of 
\SetoidCC in \cref{sec:examples}.

\section{Generalities}
\label{sec:generalities}

\subsection{Constructions and Propositions}

\SetoidCC separates types into two layers: a proof-relevant layer for 
\emph{constructions} and a proof-irrelevant layer for \emph{propositions}. 

The proof-relevant types inhabit the universe hierarchy \( \Type_i \).
% 
This layer functions exactly like usual Martin-Löf Type Theory, and
contains familiar types
\sideremark{In fact all \MLTT types are available in \SetoidCC, and the usual 
typing rules and equations still hold true.}
such as the type of natural numbers, \( \Pi \)-types, \( \Sigma \)-types or 
universes; but also new types such as subset types and quotient types.
% 
Generally speaking, proof-relevant objects correspond to mathematical 
constructions and programs.

The second layer corresponds to the impredicative universe of propositions 
\( \sProp \), which behaves rather differently.
% 
Indeed, propositions are \emph{definitionally proof-irrelevant types}, which 
means that any two inhabitants of a type \( \tm{A}{\sProp} \) are convertible
simply by virtue of having type \( A \). 
% 
This corresponds to the universe of strict propositions
\( \varsProp \) described in~\sidecitet{gilbert:hal-01859964} and implemented 
in \Coq and \Lean.
% 
Propositions contain no computational information whatsoever, but they may be 
used to express logical constraints on proof-relevant objects.
% 
Examples of propositions will include True, False, logical connectors and the 
observational equality.

These two layers are far from being hermetically sealed, though. 
% 
The complex interactions between the observational equality and the 
proof-relevant layer fundamentally changes the behavior of the theory, so
that it becomes possible to prove
\defnote{function extensionality}{Recall that function extensionality means that
pointwise equal functions are in fact equal: \( (\forall x, f\ x = g\ x) \to f = g \).} 
for the \emph{inductive equality} in the proof-relevant layer of \SetoidCC!

\subsection{The Observational Equality}
\label{sec:obseq-intro}

A central feature of \SetoidCC is that every proof-relevant
% 
\sideremark{Proof-irrelevant propositions, on their part, do not need to be equipped 
with an equality relation: since any two inhabitants are convertible, they
would always be equal by reflexivity.}
% 
type \( A \) comes equipped with a proof-irrelevant \emph{observational equality} 
type, that we write \( {\Obseq[A]{t}{u}} \).

As suggested by its name, this equality is built around the idea that two 
objects should be identified when they behave similarly with respect to all 
obervations we can make on them.
% 
For instance, the observations we can make on a function \( f : \Nat \to \Nat \) 
basically amount to applying \( f \) to some number \( n \), and computing the
result. 
% 
Thus, two integer functions \( f \) and \( g \) are observationally equal 
when \( \Obseq[\Nat]{f\ n}{g\ n} \) for all \( n : \Nat \),
which is the principle of function extensionality.

In this regard, the observational equality is similar to the univalent equality 
found in Homotopy Type Theory \sidecite{hottbook}. 
% 
But it is also fundamentally different: 
% 
by virtue of being a proof-irrelevant proposition, the observational equality 
validates the principle of Uniqueness of Identity Proofs (\UIP), while the 
equality of \HoTT equips types with the complex structure of a higher groupoid.
% 
In other words, \SetoidCC is a language for set-like objects and set-based 
mathematics, not higher mathematics.
% 
In exchange for the comfortable simplicity of \UIP, the observational equality
is not univalent, and in particular it does not identify isomorphic types.

From a computational perspective, the observational equality behaves very 
differently from the usual Martin-Löf Identity Type.
% 
The equality type \( \Obseq[A]{t}{u} \) should be understood 
as an \emph{eliminator} that computes by reducing the type \( A \) to its 
normal form, and then pattern-matches on it to produce the equality 
relation which is appropriate for \( A \). For instance, if \( A \) happens
to be a function type, then the observational equality will reduce to the
statement of function extensionality:
\[
	\Obseq[\Fun{A}{B}]{f}{g} \quad \Longrightarrow \quad \Depfun{A}{\Obseq[B]{f\ x}{g\ x}}.
\]
Likewise, all the other type formers have corresponding computation rules that
prescribe the behavior of the observational equality on their inhabitants.

\subsection{Eliminating Equality with Type Casting}
\label{sec:cast-intro}

For the observational equality to be of any use, we need a way to
use it in constructions and proofs: 
% 
\sideremark{This principle is called the Leibniz rule.}
% 
from an inhabitant of \( P\ a \) and a proof of \( \Obseq{a}{b} \), we should 
be able to derive an inhabitant of \( P\ b \).
% 
To this end, \SetoidCC provides the two primitive eliminators \( \transportName \)
and \( \castName \).

Elimination of equalities into the proof-irrelevant layer is done with 
\( \transportName \). 
% 
Since the result is computationally irrelevant, this operator is not required 
to satisfy any kind of equation -- in the proof-irrelevant world, all 
equations hold true as long as they are well-typed --
%
and thus \( \transportName \) is merely an axiom that postulates the Leibniz
rule for propositional predicates \( P : A \to \sProp \).
% 
We can use it to derive important properties of the observational equality, 
such as the fact that it is an equivalence relation, or that it is preserved
by functions:
\sideremark{The variables \( A, B, x, y \) are implicitly quantified over the 
appropriate types, which we omit to avoid clutter.}
\[
\metaop{ap} : \Depfun[f]{A \to B}{\Fun{\Obseq[A]{x}{y}}{\Obseq[B]{f\ x}{f\ y}}}.
\]

On the other hand, \( \castName \) eliminates equalities into the 
proof-relevant layer by allowing to cast terms between two observationally
equal types.
% 
Given a proof \( e : \Obseq[\Type]{A}{B} \) and an inhabitant \( t : A \), the
term \( \cast{A}{B}{e}{t} \) produces an inhabitant of \( B \) by computing the 
normal forms of the types \( A \) and \( B \), and then picking an appropriate 
computation rule according to their head constructors.
% 
For instance, if \( A \) and \( B \) are two function types, then the cast
will reduce to a function that casts back and forth:
\sideremark{In this computation, \( e \) is a proof of 
\( {\Obseq{\Fun{A}{B}}{\Fun{A'}{B'}}} \), which is actually convertible to
\( {(\Obseq{A}{A'})} \land {(\Obseq{B}{B'})}. \) We write \( e_1 \) and 
\( e_2 \) for its projections.}
\begin{align*}
& \cast{\Fun{A}{B}}{\Fun{A'}{B'}}{e}{f} \\
& \qquad \Longrightarrow \quad
\lam{A'}{\cast{B}{B'}{e_2}{f\ \cast{A'}{A}{e_1}{x}}}.
\end{align*}
% 
Just like with the observational equality, every type constructor comes with
rules that describe the behavior of \( \castName \) on its elements.
% 
Note that the equality proof \( e \) plays no computational role, and is just
here to ensure that the cast is consistent.

The \( \castName \) operator, despite its apparent simplicity, is in fact enough
to derive the \( J \) eliminator of \MLTT. Indeed, the \( J \) eliminator is
equivalent to the Leibniz rule and the contractibility of singletons 
\sidecite{hottbook}, but the contractibility of singletons is implied by 
proof irrelevance of the equality. Finally, the Leibniz rule is a consequence 
of \( \metaop{ap} \) and \( \castName \).


\section{The Formal System \SetoidCC}
\label{sec:typing-rules}

\shepherd{For convenience, the full set of rules is collected in the appendix.}

\subsection{Syntax}

% SetoidCC syntax
\begin{figure}
	\begin{small}
		\[
		\begin{array}{lclcl}
		i,j								& \bnfin	& \Nat																					&  & \text{Universe levels}\\
		s									& \bnfis	& \Type_i \qsep \sProp														&  & \text{Universes}\\
		\Gamma , \Delta   & \bnfis	& \emptyctx 
																\qsep \extctxannotated{\Gamma}{A}{s}						&  & \text{Contexts}\\
		t,u,m,n,e,A,B     & \bnfis	& x \qsep s 																		&  & \text{Variables and Universes}\\
											& \sep		& \lam{A}{t} \qsep t\ u 
																\qsep \Depfunannotated{A}{B}{s}{s}{s'} 					&  & \text{Dependent products}\\
											& \sep		& \zero \qsep \suc{t} \qsep \natrec{P}{t}{u}{n} 
																\qsep \Nat																			&  & \text{Natural numbers}\\
											& \sep		& \pair{t}{u} \qsep \fst{t} \qsep \snd{t} 
																\qsep \Existsannotated{A}{B}{i}{j} 							&  & \text{Existential types}\\
											& \sep		& \emptyrec{A}{t} \qsep \Empty									&  & \text{Empty type}\\
											& \sep		& \unit \qsep \Unit															&  & \text{Singleton type}\\
											& \sep		& \Obseq[A]{t}{u} \qsep \refl{t}{A} 
																\qsep \transport{A}{t}{B}{u}{t'}{e}							&  & \text{Observational equality}\\
											& \sep		& \cast{A}{B}{e}{t} \qsep \castrefl{A}{t}				&  & \text{Type cast}
		\end{array}
		\]
	\end{small}
	\caption{Syntax of \SetoidCC}
	\label{fig:syntax}
\end{figure}

The syntax of the sorts, contexts, terms and types of \SetoidTT is
specified in \cref{fig:syntax}.
%
The theory features cumulative dependent functions (noted $\Depfunannotated{A}{B}{s}{i}{j}$) with
\( \eta \)-equality, natural numbers, as well as proof-irrelevant dependent
sums (noted $\Exists{A}{B}$), a proof-irrelevant empty type (noted
$\Empty$) and unit type (noted $\Unit$).
%
When \( B \) does not depend on \( A \), we write \( \Fun{A}{B} \) instead of
\( \Depfun{A}{B} \), and \( \Prod{A}{B} \) instead of \( \Exists{A}{B} \). The capture-avoiding
substitution of a variable \( x \) in a term \( A \) by the term \( t \) is noted
\( \subst{B}{t} \).
%
\SetoidTT can also be extended with more primitives such as quotients or general inductive types,
but we defer the treatment of those to \cref{sec:extens-quot-id} to better focus on the
treatment of equality in the theory.

\subsection{Structure of the Rules}

The typing rules of \SetoidTT are based on six different judgments: 
\sideremark{In all the judgments, \( \Univ \) is either \( \Type_i \) or \( \sProp \).
Note that the reduction only makes sense for proof-relevant terms, so it does not 
to mention the sort.}
\[
  \begin{array}{lr}
    \wfctx{\Gamma} & \text{the context \( \Gamma \) is well-formed} \\
    \tytm{\Gamma}{A}{\Univ} & \text{the type \( A \) has sort \( \Univ \) in context \( \Gamma \)} \\
    \eqtm{\Gamma}{A}{B}{\Univ} & \text{\( A \) and \( B \) are convertible types of sort \( \Univ \) in context \( \Gamma \)} \\
    \tytmannotated{\Gamma}{t}{A}{\Univ} & \text{the term \( t \) has type \( A \) in context \( \Gamma \)} \\
    \eqtmannotated{\Gamma}{t}{u}{A}{\Univ} & \text{\( t \) and \( u \) are convertible at type \( A \) in context \( \Gamma \)} \\
    \redannotated{\Gamma}{t}{u}{A} & \qquad\text{the term \( t \) reduces to \( u \) at type \( A \) in context \( \Gamma \)}
  \end{array}
\]
As is often the case in type theory, the rules are organized in a very 
systematic structure:
% 
every type former comes with rules that describe its formation, introduction, 
elimination and computation.
% 
On top of this, \SetoidCC adds rules that describe the observational equality 
and the behavior of type-casting.

\subsection{Generic Rules}

\paragraph*{Contexts}
Rules~\nameref{infrule:ctx-nil}, \nameref{infrule:ctx-cons} and \nameref{infrule:var} describe the
usual formation of contexts and typing of variables. 
% 
\begin{mathpar}
    \inferrule[Ctx-Nil]
        { }
        {\wfctx{\emptyctx}}
    \ilabel{infrule:ctx-nil}
    \and
    \inferrule[Ctx-Cons]
        {\wfctx{\Gamma} \\ \tytm{\Gamma}{A}{\Univ}}
        {\wfctx{\extctxannotated{\Gamma}{A}{\Univ}}}
    \ilabel{infrule:ctx-cons}
	\and
    \inferrule[Var]
        {\wfctx{\Gamma} \\ \inctx{\Gamma}{A}{\Univ}}
        {\tytmannotated{\Gamma}{x}{A}{\Univ}}
    \ilabel{infrule:var}
\end{mathpar}

\paragraph*{Conversion}

Conversion is an equivalence relation that is preserved by typing, and it 
subsumes the reduction of proof-relevant terms and the convertibility of
proof-irrelevant terms.
% 
\begin{mathpar}
    \inferrule[conv]
        {\tytmannotated{\Gamma}{t}{A}{\Univ}
            \\ \eqtm{\Gamma}{A}{B}{\Univ}}
        {\tytmannotated{\Gamma}{t}{B}{\Univ}}
    \ilabel{infrule:conv}
	\and
    \inferrule[Refl]
        {\tytmannotated{\Gamma}{t}{A}{\Univ}}
        {\eqtmannotated{\Gamma}{t}{t}{A}{\Univ}}
    \ilabel{infrule:reflexivity}
\end{mathpar}
\begin{mathpar}
    \inferrule[Sym]
        {\eqtmannotated{\Gamma}{t}{u}{A}{\Univ}}
        {\eqtmannotated{\Gamma}{u}{t}{A}{\Univ}} 
    \ilabel{infrule:sym}
    \and
    \inferrule[Trans]
        {\eqtmannotated{\Gamma}{t}{t'}{A}{\Univ}
            \and \eqtmannotated{\Gamma}{t'}{u}{A}{\Univ}}
        {\eqtmannotated{\Gamma}{t}{u}{A}{\Univ}}
    \ilabel{infrule:trans}
\end{mathpar}
\begin{mathpar}
    \inferrule[Red-Conv]
        {\red{\Gamma}{t}{u}{A}}
        {\eqtmannotated{\Gamma}{t}{u}{A}{\Type_i}}
    \ilabel{inferrule:red-conv}
	\and
    \inferrule[Proof-Irrelevance]
        {\tytmannotated{\Gamma}{t,u}{A}{\sProp}}
        {\eqtmannotated{\Gamma}{t}{u}{A}{\sProp}}
    \ilabel{infrule:proof-irrelevance}
\end{mathpar}
% 
On top of this, we need to add bureaucratic congruence rules which make sure
that each constructor preserves the judgmental equality.
% 
Since these rules present little interest, we do not reproduce them here.

\subsection{The Logical Layer}

\paragraph*{Impredicative \( \Pi \)-Types}

Given a type \( A \) and a proof-irrelevant family \( B : A \to \sProp \)
on it, the system allows the formation of a proof-irrelevant \( \Pi \)-Type, 
with the usual introduction and elimination rules.
\sideremark{There is no need for \( \beta \)-reduction or an \( \eta \) rule, 
since this type lives in the proof-irrelevant world.}
% 
\begin{mathpar}
    \inferrule[$\Pi$-Irr-Form]
        {%\tytm{\Gamma}{A}{\Univ}
            \tytm{\extctxannotated{\Gamma}{A}{\Univ}}{B}{\sProp}}
        {\tytm{\Gamma}{\Depfunannotated{A}{B}{\Univ}{\Univ}{\sProp}}{\sProp}}
        {}
    \ilabel{infrule:pi-irr-form}
	\and
	\inferrule[Fun-Irr]
        {\tytmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t}{B}{\sProp}}
        {\tytmannotated{\Gamma}{\lam{A}{t}}{\Depfun{A}{B}}{\sProp}}
    \ilabel{infrule:pi-irr-intro}
    \and
    \inferrule[App-Irr]
        {\tytmannotated{\Gamma}{t}{\Depfun{A}{B}}{\sProp}
            \\ \tytmannotated{\Gamma}{u}{A}{\Univ}}
        {\tytmannotated{\Gamma}{t\ u}{\subst{B}{u}}{\sProp}}
    \ilabel{infrule:pi-irr-elim}
\end{mathpar}
% 
Depending on the sort of the domain \( A \), the \( \Pi \)-Type might play 
the role of a universal quantification on a proof-relevant type, or that of 
a dependent implication between propositions.

Note that this rule makes \( \sProp \) into an 
\defnote{impredicative}{A sort is said to be impredicative if it is closed under 
dependent products over any index type.}
sort.
% 
In particular, it allows the definition of self-referential propositions,
which quantify over the type \( \sProp \) of all propositions and may thus
be applied to themselves.
%
In addition to providing a tremendous amount of raw logical power, 
impredicativity is a remarkably flexible tool to define new propositions and
abstractions.
% 
This versatility makes impredicativity a crucial ingredient of numerous 
tools in constructive mathetmatics, such as Tarski's fixed point theorem or 
lattice theory~\sidecite{paco}.

\paragraph*{Dependent Conjunctions and Existential Types}
% 
As a testament to the expressivity power of impredicativity, we use it to 
derive new logical primitives, using the well-known technique of impredicative 
encodings.

Given a proposition \( A \) and a second proposition \( B \) that depends on 
\( A \), we form the dependent conjunction of \( A \) and \( B \) as follows
\[
	\Exists{A}{B} \quad := \quad \Depfun[X]{\sProp}{\Fun{(\Fun{\Depfun{A}{B}}{X})}{X}}.
\]
Now, from a proof \( a \) of \( A \) and a proof \( b \) of \( \subst{B}{a} \), 
we can derive a proof of \( \Exists{A}{B} \) as a simple function
\[
	\pair{a}{b} \quad := \quad \lambda\ X\ H\ .\ H\ a\ b
\]
and given a proof \( t \) of \( \Exists{A}{B} \), we define the following eliminators:
\[
\begin{array}{rll}
	\fst{t} \quad & := \quad t\ A\ (\lambda\ a\ b\ .\ a) & : \quad A \\
	\snd{t} \quad & := \quad t\ (B\ \fst{t})\ (\lambda\ a\ b\ .\ b) & : \quad B\ \fst{t}.
\end{array}
\]
Likewise, we can replicate the exact same definitions when \( A \) is a 
proof-relevant type and \( B \) a dependent proposition to obtain an 
existential type \( \varExists{A}{B} \).

\paragraph*{Empty and Unit type}

To represent falsity and truth, \SetoidTT features the empty 
type $\Empty$ and the unit type $\Unit$.

Besides its formation rule (Rule~\nameref{infrule:empty-form}), the empty type 
comes with an elimination principle (Rule~\nameref{infrule:empty-elim}) that 
can eliminate it into both proof-irrelevant and proof-relevant types.
\sideremark{This large elimination rule means that we could not replace 
\( \Empty \) with some impredicative encoding.}
% 
\begin{mathpar}
    \inferrule[$\Empty$-Form]
        {\wfctx{\Gamma}}
        {\tytm{\Gamma}{\Empty}{\sProp}}
    \ilabel{infrule:empty-form}
    \and
    \inferrule[$\Empty$-Elim]
        {\tytm{\Gamma}{A}{\Univ}
            \\ \tytmannotated{\Gamma}{t}{\Empty}{\sProp}}
        {\tytmannotated{\Gamma}{\emptyrec{A}{t}}{A}{\Univ}}
    \ilabel{infrule:empty-elim}
\end{mathpar}
% 
In the theory implemented by \Coq, this rule constitutes the 
unique connection between the proof-irrelevant and relevant types. 
% 
This means that the only way to use information from a proof-irrelevant term 
to build a proof-relevant term is by using a proof of $\Empty$, which
amounts to proving that actually we are in an inaccessible branch or
impossible case.
%
In \SetoidCC however, there is another way of using proof irrelevant 
information to build a proof relevant term, by transporting (or casting) 
along a proof of equality.

The unit type on the other hand only requires a formation rule and a 
constructor~$\unit$. It does not require an eliminator, since the usual one 
can be derived from proof irrelevance.
% 
Thus, we can simply define them as 
\[ 
	\begin{array}{rll}
	\Unit \quad & := \quad \Fun{\Empty}{\Empty} & : \quad \sProp \\
	\unit \quad & := \quad \lam{\Empty}{x} & : \quad \Unit.
	\end{array}
\]

\paragraph*{The Observational Equality}

As we explained in \cref{sec:obseq-intro}, a central feature of \SetoidCC is 
that every proof-relevant type comes equipped with a proof-irrelevant equality 
type, noted $\Obseq[A]{t}{u}$ and a canonical way to inhabit it, with the 
reflexivity constructor $\refl{t}{A}$.
%
\begin{mathpar}
	\inferrule[Eq-Form]
        {%\tytm{\Gamma}{A}{\Type_i} \\
            \tytmannotated{\Gamma}{t}{A}{\Type_i}
            \\ \tytmannotated{\Gamma}{u}{A}{\Type_i}}
        {\tytm{\Gamma}{\Obseq[A]{t}{u}}{\sProp}}
    \ilabel{infrule:eq-form}
    \and
    \inferrule[Refl]
        {% \tytm{\Gamma}{A}{\Type_i} \\
            \tytmannotated{\Gamma}{t}{A}{\Type_i}}
        {\tytmannotated{\Gamma}{\refl{t}{A}}{\Obseq[A]{t}{t}}{\sProp}}
    \ilabel{infrule:refl}
\end{mathpar}
%
The equality type of \SetoidCC should not be seen as a type former like
the identity type of \MLTT, but rather as an eliminator that produces a
proposition by case analysis on the head constructor of the type \( A \).

To transport a proof of a proposition along an observational equality, 
\SetoidCC provides the eliminator \( \transportName \).
%
\begin{mathpar}
	\inferrule[Transport-$\sProp{}$]
        {%\tytm{\Gamma}{A}{\Type_i}
            \tytmannotated{\Gamma}{t,t'}{A}{\Type_i}
            \quad \tytm{\extctx[x]{\Gamma}{A}}{B}{\sProp} \\
            % \quad \tytm{\Gamma}{B}{\sProp[j]}
            \tytmannotated{\Gamma}{u}{\subst[x]{B}{t}}{\sProp}
            %\quad \tytmannotated{\Gamma}{t'}{A}{\Univ}
            \quad \tytmannotated{\Gamma}{e}{\Obseq[A]{t}{t'}}{\sProp}}
        {\tytmannotated{\Gamma}{\transport{A}{t}{B}{u}{t'}{e}}{\subst[x]{B}{t'}}{\sProp}}
    \ilabel{infrule:transport-prop}
\end{mathpar}
%
Since it only ever constructs computationally irrelevant terms, this eliminator
does not need any computational rule.
%
Using $\transportName$, we can prove that the observational equality is in
fact an equivalence relation, and we note $\sym{e}$ for the inverse of $e$, 
\( \transitivity{e}{e'} \) for the transitivity, and $\ap{f}{e}$ for the 
preservation of equality by non-dependent function.

To deal with elimination of equality in a proof relevant context, 
\SetoidCC provides a \( \castName \) primitive that handles transport between 
two propositionally equal proof relevant types.
% 
\begin{mathpar}
    \inferrule[Cast]
        {% \tytm{\Gamma}{A}{\Univ_i}   \quad \tytm{\Gamma}{B}{\Univ_i}
            \tytmannotated{\Gamma}{e}{\Obseq[{\Univ}]{A}{B}}{\sProp}
            \quad \tytmannotated{\Gamma}{t}{A}{\Univ}}
        {\tytmannotated{\Gamma}{\cast{A}{B}{e}{t}}{B}{\Univ}}
    \ilabel{infrule:cast}
\end{mathpar}
% 
Note that our cast operation also applies to proof-irrelevant
types.
% 
This is technically unnecessary as \( \transportName \) subsumes this case, 
but it will allow us to write more uniform reduction rules.
%
The term \( \cast{A}{B}{e}{t} \) computes by case analysis on \( A \) and 
\( B \), with specific computation rules for each type former 
(which are described in \cref{sec:universe}).
% 
The equality proof \( e \) plays no role in the computation whatsoever, and 
is only here to make sure the cast is consistent.

By default, \( \castName \) applied to reflexivity only reduces to the
identity function if the terms \( A \) and \( B \) are closed. 
% 
To make up for this state of affairs, \SetoidCC provides a proof-irrelevant 
axiom $\castreflName$ which asserts that casting along reflexivity is the 
identity.
% 
\begin{mathpar}
    \inferrule[Cast-Refl]
        {%\tytm{\Gamma}{A}{\Univ_i}
            \tytmannotated{\Gamma}{t}{A}{\Type_i} \\
            \tytmannotated{\Gamma}{e}{\Obseq[{\Type_i}]{A}{A}}{\sProp}}
        {\tytm{\Gamma}{\castrefl{A}{t}}{\Obseq[A]{t}{\cast{A}{A}{e}{t}}}}
    \ilabel{infrule:cast-refl}
\end{mathpar}
% 
In \shepherd{TODO}, we study a slight variant of the system where the rule
\nameref{infrule:cast-refl} holds computationally, but whose normalization
and canonicity are only conjuctural.

\subsection{Dependent products}

The formation of dependent products between a domain and a codomain that have
different sorts and universe levels is allowed. The resulting type has the same
relevance as the codomain, and a universe level that is higher than both the level of
the domain and the level of the codomain.
% 
\begin{mathpar}
    \inferrule[$\Pi$-Form]
        {%\tytm{\Gamma}{A}{\Univ}
            \tytm{\extctxannotated{\Gamma}{A}{\Univ}}{B}{\Univ '}}
        {\tytm{\Gamma}{\Depfunannotated{A}{B}{s}{s}{s'}}{\piRel{\Univ}{\Univ '}}}
        {}
    \ilabel{infrule:pi-form}
\end{mathpar}
%
The sort of the domain and the levels of both the domain and the codomain are
collected as annotations to the dependent function type for the convenience of the
type checking algorithm.
%
Note that the introduction of cumulativity in the formation of
dependent products is a necessary complication of \SetoidTT as
the rules that provide us with propositional extensionality and
function extensionality can only be well-typed in the presence of cumulativity.

\begin{mathpar}
	\inferrule[Fun]
        {\tytmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t}{B}{\Univ'}}
        {\tytmannotated{\Gamma}{\lam{A}{t}}{\Depfun{A}{B}}{\piRel{\Univ}{\Univ '}}}
    \ilabel{infrule:pi-intro}
    \and
    \inferrule[App]
        {\tytmannotated{\Gamma}{t}{\Depfun{A}{B}}{\piRel{\Univ}{\Univ '}}
            \\ \tytmannotated{\Gamma}{u}{A}{\Univ}}
        {\tytmannotated{\Gamma}{t\ u}{\subst{B}{u}}{\Univ '}}
    \ilabel{infrule:pi-elim}
\end{mathpar}

Rules~\nameref{infrule:pi-intro} and \nameref{infrule:pi-elim} are the
usual rules of $\lambda$-abstraction and application. Note that the sort and level annotation
are implicit as they can be inferred from the premises.

\inferrule[$\eta$-Eq]
{\tytmannotated{\Gamma}{t, u}{\Depfunannotated{A}{B}{}{\Univ}{\Type_i}}{\piRel{\Univ}{\Type_i}}
	\\ \eqtmannotated{\extctxannotated{\Gamma}{A}{\Univ}}{t\ x}{u\ x}{B}{\Type_i}}
{\eqtmannotated{\Gamma}{t}{u}{\Depfunannotated{A}{B}{}{\Univ}{\Type_i}}{\piRel{\Univ}{\Type_i}}}
\ilabel{infrule:eta}

\subsection{Dependent Sums}

\begin{mathpar}
  \inferrule[Eq-Pair]{\tytm{\Gamma}{a}{A} \\ \tytm{\Gamma}{a'}{A} \\
    \tytm{\Gamma}{b}{\subst{B}{a}}
            \\ \tytm{\Gamma}{b'}{\subst{B}{a'}} \\ e' := \ap{B}{e}} %\transport{}{a}{\lam{A}{B}}{a'}{e}{b}{}}
            {\red{\Gamma}{\Path[\Sigma A B]{(a;b)}{(a';b')}}{\Exists[e]{\Path[A]{a}{a'}}
                {\Path[B]{\cast{\subst{B}{a}}{\subst{B}{a'}}{e'}{b}}{b'}}}{\sProp[i]}}
          \ilabel{inferrule:eq-pair}
\end{mathpar}
%
We conjecture that the reduction of equality and cast for
any indexed inductive types as defined in \CIC can be described, although we
leave the general construction for future work.

\section{Natural numbers}

Strictly speaking, all inductive types could be excluded from the core of \SetoidTT , and be
considered as extensions. However, we decided to treat the example of natural numbers as we
feel it is both very simple and a good illustration.

The type $\Nat$ comes with a formation rule \nameref{infrule:nat-form}, constructors $\zero$
(Rule~\nameref{infrule:zero}) and $\sucName$  (Rule~\nameref{infrule:suc})
and an elimination/induction principle given by Rule~\nameref{infrule:nat-elim}.

\begin{mathpar}
    \inferrule[$\Nat$-Form]
        {\wfctx{\Gamma}}
        {\tytm{\Gamma}{\Nat}{\Type_0}}
    \ilabel{infrule:nat-form}
    \and
    \inferrule[Zero]
        {\wfctx{\Gamma}}
        {\tytmannotated{\Gamma}{\zero}{\Nat}{\Type_0}}
    \ilabel{infrule:zero}
    \and
    \inferrule[Suc]
        {\tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
        {\tytmannotated{\Gamma}{\suc{n}}{\Nat}{\Type_0}}
    \ilabel{infrule:suc}
    \and
    \inferrule[$\Nat$-Elim]
        {\tytmannotated{\Gamma}{t_0}{A\ \zero}{\Univ}
            \\ \tytmannotated{\Gamma}{t_S}{\Depfun[n]{\Nat}{\Fun{A\ n}{A\ (\suc{n})}}}{\Univ}
            \\ \tytmannotated{\Gamma}{n}{\Nat}{\Type_0}}
        {\tytmannotated{\Gamma}{\natrec{A}{t_0}{t_S}{n}}{A\ n}{\Univ}}
    \ilabel{infrule:nat-elim}
\end{mathpar}

\subsection{Universes}
\label{sec:universe}

The formation rule for universes (Rule~\nameref{infrule:univ}) states
that both \( \Type_i \) and \( \sProp[i] \) are relevant types. It is natural
for \( \sProp \) to be proof-relevant, since its inhabitants are
types which are not convertible to one another despite being proof-irrelevant.




\cref{fig:SetoidTT-reduction} describes the reduction in
\SetoidTT. Note that since reduction is typed,
one needs to add a rule for type conversion
(Rule~\nameref{inferrule:conv-red}).
%
Reduction features the usual notion of $\beta$-reduction
(Rule~\nameref{inferrule:beta-red}), which corresponds to the
computation rule of application (the eliminator of dependent
functions) applied to a $\lambda$-term (the constructor of dependent
functions).
%
Similarly, rules \nameref{inferrule:nat-elim-zero} and
\nameref{inferrule:nat-elim-suc} describe the two computation rules
of the eliminator of $\Nat$, one for each constructor of $\Nat$.

As mentioned previously, the equality type and type cast operation of
\SetoidTT are eliminators, and thus must come with their
computation rules.
%
Since $\Path[A]{t}{u}$ is an eliminator for the universe, it needs rules
for every type constructor.
%
Rule \nameref{inferrule:eq-fun} is the computation rule for dependent
functions which stipulates that two functions are equal when they
are pointwise equal, thus naturally providing \SetoidTT with
function extensionality.
%
Rule \nameref{inferrule:eq-sprop} says that two proof irrelevant
types are equal when they are logically equivalent, thus
providing \SetoidTT with propositional extensionality. Note that
cumulativity is required for this reduction rule to preserve typing,
as the types $A$ and $B$ live in a universe below $\Path[{\sProp[i]}]{A}{B}$.

There are three reduction rules for equality in \( \Type \).
Rule \nameref{inferrule:eq-univ} stipulates that when the two
endpoints are both $\Nat$ or the same universe, the equality holds,
which is captured by the fact that it reduces to the unit type.
%
Rule \nameref{inferrule:eq-univ-noeq} says that when the two end
points do not have the same head $\head{}$, the equality does not hold, which
is captured by the fact that it reduces to the empty type. The
function $\head{A}$ is simply equal to $\Nat$ or $\Type[i]{}$ when
$A$ is the type of natural numbers or a universe respectively, and is
defined as $(\Pi, s, i, j)$ when $A$ is the type $\Depfunannotated{A}{B}{s}{i}{j}$.
%
The third rule (Rule \nameref{inferrule:eq-pi}) says that
two dependent function types are equal when their domain are equal,
and their codomain are pointwise equal (as type families) up to
the equality on their domain.
% The reader familiar with homotopy type
% theory will recognize the usual characterization of equality on
% dependent function types in presence of univalence \sidecitet{hottbook},
% but here, this equality holds definitionally, without univalence, and
% corresponds to function extensionality at the level of type
% families.
%
As for Rule \nameref{inferrule:eq-sprop}, this rule is well-typed
only in presence of cumulativity.

There are four rules for equality in \( \Nat \), corresponding
to every possible normal forms of the endpoints. Equality holds
when both endpoints are $\zero$ (Rule \nameref{inferrule:eq-zero}),
computes to the equality of arguments when both endpoints are successors (Rule
\nameref{inferrule:eq-suc}), and does not hold otherwise
(Rules \nameref{inferrule:eq-zero-suc} and \nameref{inferrule:eq-suc-zero}).
This concludes the reduction rules for equality.

We can now turn to the description of the computation rules for type
cast, which only need to be defined when the types are
compatible---otherwise the cast will be stuck.\footnote{An alternative
  design would be to reduce to an elimination on the proof of equality which in this case
has type $\Empty$.}
%
Casting from $\Nat$ to $\Nat$ is defined by recursion to be the identity
on constructors (Rules \nameref{inferrule:cast-zero} and
\nameref{inferrule:cast-suc}), and casting a type from a universe to
the same universe is the identity\footnote{We could also define it by recursion. It is not clear whether it makes any significant
difference.}
(Rule \nameref{inferrule:cast-univ}).
%
Finally, casting between two dependent products is more involved: it
produces a new function by casting back and forth the argument and return
value of the original function (Rule \nameref{inferrule:cast-pi}).





For our definition of reduction to be complete, we need to add rules that
reduce the scrutinees of eliminators to {\em weak-head normal form} (whnf),
so the eliminator can then reduce by case analysis on the whnf.
%
Weak-head normal forms correspond to relevant terms that can \emph{not} be
reduced (\cref{fig:whnf-neutral}).
%
They are either terms with a constructor in head position, or a neutral term, which
correspond to the stuck terms that can not exist in an empty
context. Neutral terms are either variables, eliminators applied to another neutral
term, or obtained from an inhabitant of \( \Empty \).
%
In \SetoidTT, inhabitants of a proof-irrelevant type are never
considered as whnf, as there is no notion of reduction of
proof-irrelevant terms.
%
Substitution rules that implement reduction of scrutinees to weak-head normal
form are described in \cref{sec:congr-subst-rules}, \cref{fig:SetoidTT-substitution}.

\section{Examples}
\label{sec:examples}

\shepherd{TODO}

\section{Properties}
\label{sec:properties}
\shepherd{unique choice}

\shepherd{TODO}